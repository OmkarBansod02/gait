{
  "panelChats": [
    {
      "ai_editor": "cursor",
      "customTitle": "Managing .gitignore and CLI Commands",
      "id": "9d15c6c4-acc3-43b5-a67c-fd69a4558caa",
      "parent_id": null,
      "created_on": "2024-10-02T07:03:57.307Z",
      "messages": [
        {
          "id": "c75f8b50-c029-4fb1-98e0-504b6ddeaf88",
          "messageText": "how to make .gitignore respect cli command",
          "responseText": "To make the `.gitignore` file respect a CLI command, you typically don't modify the `.gitignore` file itself. Instead, you can use Git commands to temporarily ignore or include files that are otherwise controlled by `.gitignore`. Here are a few approaches you can use:\n\n1. To temporarily ignore changes to a tracked file:\n\n```\ngit update-index --assume-unchanged <file>\n```\n\nTo undo this:\n\n```\ngit update-index --no-assume-unchanged <file>\n```\n\n2. To force add a file that's ignored:\n\n```\ngit add -f <file>\n```\n\n3. To check why a file is being ignored:\n\n```\ngit check-ignore -v <file>\n```\n\n4. To temporarily allow ignored files in your next commit:\n\n```\ngit add -A\ngit commit -m \"Your message\" --no-verify\n```\n\nThese commands allow you to override `.gitignore` behavior from the command line without modifying the `.gitignore` file itself. Choose the appropriate command based on your specific needs.",
          "model": "claude-3.5-sonnet",
          "timestamp": "2024-10-02T07:03:57.307Z",
          "context": [
            {
              "context_type": "file",
              "key": "d176861a-238e-463f-b5d6-99e0f1bb550c",
              "value": {
                "human_readable": "/Users/kylel1/Documents/GitHub/gait-copilot/.gitignore",
                "uri": "/Users/kylel1/Documents/GitHub/gait-copilot/.gitignore",
                "isCurrentFile": true
              }
            }
          ],
          "kv_store": {}
        }
      ],
      "kv_store": {}
    },
    {
      "ai_editor": "cursor",
      "customTitle": "Adding File Open Command and Relative Path Display",
      "id": "0b0391d4-bc06-4d42-a3c5-53174ba8c4b7",
      "parent_id": null,
      "created_on": "2024-09-30T05:58:32.649Z",
      "messages": [
        {
          "id": "c5f89109-5962-4ce2-aee5-e940b75bc5e5",
          "messageText": "add the openFile command mentioned in human_readable onclick. Also, make human_readable show a relative path instead of an absolute path",
          "responseText": "Certainly! I'll add the `openFile` command handler and modify the `human_readable` path to show a relative path instead of an absolute one. Here are the changes we need to make:\n\n```typescript:src/panelview.ts\n// ... existing code ...\n\nexport class PanelViewProvider implements vscode.WebviewViewProvider {\n    // ... existing code ...\n\n    public resolveWebviewView(\n        webviewView: vscode.WebviewView,\n        context: vscode.WebviewViewResolveContext,\n        _token: vscode.CancellationToken\n    ) {\n        // ... existing code ...\n\n        webviewView.webview.onDidReceiveMessage(message => {\n            switch (message.command) {\n                // ... existing cases ...\n                case 'openFile':\n                    this.handleOpenFile(message.path);\n                    break;\n                default:\n                    break;\n            }\n        });\n\n        // ... existing code ...\n    }\n\n    /**\n     * Handles opening a file in the editor.\n     * @param filePath - The path of the file to open.\n     */\n    private async handleOpenFile(filePath: string) {\n        try {\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n            if (!workspaceFolder) {\n                vscode.window.showErrorMessage('No workspace folder found.');\n                return;\n            }\n\n            const fullPath = vscode.Uri.file(path.join(workspaceFolder.uri.fsPath, filePath));\n            const document = await vscode.workspace.openTextDocument(fullPath);\n            await vscode.window.showTextDocument(document);\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to open file: ${error.message}`);\n        }\n    }\n\n    // ... existing code ...\n\n    private getHtmlForWebview(webview: vscode.Webview): string {\n        // ... existing code ...\n\n        return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<!-- ... existing HTML ... -->\n<script nonce=\"${nonce}\">\n    // ... existing JavaScript ...\n\n    window.addEventListener('message', event => {\n        const message = event.data;\n        if (message.type === 'update') {\n            // ... existing code ...\n\n            if (messageEntry.context && Array.isArray(messageEntry.context) && messageEntry.context.length > 0) {\n                const contextDiv = document.createElement('div');\n                contextDiv.className = 'context';\n                contextDiv.style.fontSize = '0.8em';\n                contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                const humanReadableContext = messageEntry.context\n                    .filter(item => item && typeof item === 'object' && item.value && typeof item.value === 'object' && typeof item.value.human_readable === 'string')\n                    .map(item => {\n                        // Get the relative path\n                        const relativePath = item.value.human_readable.split('/').slice(-2).join('/');\n                        return \\`<a href=\"#\" onclick=\"vscode.postMessage({command: 'openFile', path: '\\${item.value.human_readable}'}); return false;\">\\${escapeHtml(relativePath)}</a>\\`;\n                    })\n                    .join(', ');\n                if (humanReadableContext) {\n                    contextDiv.innerHTML = \\`<strong>Context:</strong> \\${humanReadableContext}\\`;\n                    messageContainer.appendChild(contextDiv);\n                }\n            }\n\n            // ... existing code ...\n        }\n    });\n\n    // ... existing JavaScript ...\n</script>\n</body>\n</html>\n        `;\n    }\n}\n\n// ... existing code ...\n```\n\nThese changes accomplish the following:\n\n1. We've added a new case in the `onDidReceiveMessage` handler to handle the 'openFile' command.\n\n2. We've implemented a new `handleOpenFile` method that opens the specified file in the VS Code editor. It constructs the full path by joining the workspace folder path with the provided relative path.\n\n3. In the HTML/JavaScript part, we've modified the context display logic to show only the last two parts of the file path (which typically includes the folder and file name) instead of the full absolute path. This provides a more concise and readable context display.\n\n4. The `onclick` handler for the context links now sends the full `human_readable` path to the `openFile` command, ensuring that the correct file is opened even though we're displaying a shortened path.\n\nThese changes will allow users to click on the context links to open the relevant files, and the context display will show more user-friendly relative paths instead of full absolute paths.",
          "model": "claude-3.5-sonnet",
          "timestamp": "2024-09-30T05:58:32.649Z",
          "context": [
            {
              "context_type": "file",
              "key": "0e5fd45c-4b55-40e6-b117-0e4ef7bb545b",
              "value": {
                "human_readable": "/Users/alex/Documents/GitHub/gait-copilot/src/panelview.ts",
                "uri": "/Users/alex/Documents/GitHub/gait-copilot/src/panelview.ts",
                "isCurrentFile": true
              }
            }
          ],
          "kv_store": {
            "file_paths": [
              "src/panelview.ts"
            ]
          }
        },
        {
          "id": "2a59a288-465c-489b-9431-3dc59e1549f2",
          "messageText": "I am getting Refused to execute inline event handler because it violates the following Content Security Policy directive: \"script-src 'nonce-OvuNcaWrdZnX6vCcETCLuwaE13nDCW24' 'self' https://*.vscode-cdn.net\". Either the 'unsafe-inline' keyword, a hash ('sha256-...'), or a nonce ('nonce-...') is required to enable inline execution. Note that hashes do not apply to event handlers, style attributes and javascript: navigations unless the 'unsafe-hashes' keyword is present.\n\nalso, explain the relative path logic",
          "responseText": "I apologize for the oversight. You're right, and this error is due to the Content Security Policy (CSP) restrictions in VS Code webviews. Let's fix this issue and explain the relative path logic.\n\nFirst, let's modify the code to avoid inline event handlers:\n\n```typescript:src/panelview.ts\n// ... existing code ...\n\nprivate getHtmlForWebview(webview: vscode.Webview): string {\n    // ... existing code ...\n\n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<!-- ... existing HTML ... -->\n<script nonce=\"${nonce}\">\n    // ... existing JavaScript ...\n\n    window.addEventListener('message', event => {\n        const message = event.data;\n        if (message.type === 'update') {\n            // ... existing code ...\n\n            if (messageEntry.context && Array.isArray(messageEntry.context) && messageEntry.context.length > 0) {\n                const contextDiv = document.createElement('div');\n                contextDiv.className = 'context';\n                contextDiv.style.fontSize = '0.8em';\n                contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                const humanReadableContext = messageEntry.context\n                    .filter(item => item && typeof item === 'object' && item.value && typeof item.value === 'object' && typeof item.value.human_readable === 'string')\n                    .map(item => {\n                        // Get the relative path\n                        const relativePath = item.value.human_readable.split('/').slice(-2).join('/');\n                        const link = document.createElement('a');\n                        link.href = '#';\n                        link.textContent = escapeHtml(relativePath);\n                        link.dataset.path = item.value.human_readable;\n                        link.addEventListener('click', (e) => {\n                            e.preventDefault();\n                            vscode.postMessage({command: 'openFile', path: e.target.dataset.path});\n                        });\n                        return link.outerHTML;\n                    })\n                    .join(', ');\n                if (humanReadableContext) {\n                    contextDiv.innerHTML = \\`<strong>Context:</strong> \\${humanReadableContext}\\`;\n                    messageContainer.appendChild(contextDiv);\n                }\n            }\n\n            // ... existing code ...\n        }\n    });\n\n    // Add a global click event listener for context links\n    document.addEventListener('click', (e) => {\n        if (e.target && e.target.tagName === 'A' && e.target.dataset.path) {\n            e.preventDefault();\n            vscode.postMessage({command: 'openFile', path: e.target.dataset.path});\n        }\n    });\n\n    // ... existing JavaScript ...\n</script>\n</body>\n</html>\n    `;\n}\n\n// ... existing code ...\n```\n\nNow, let's explain the changes and the relative path logic:\n\n1. CSP Issue Fix:\n   Instead of using inline `onclick` handlers, we're now creating the link elements programmatically and adding event listeners to them. This approach complies with the CSP restrictions.\n\n2. Relative Path Logic:\n   ```javascript\n   const relativePath = item.value.human_readable.split('/').slice(-2).join('/');\n   ```\n   This line creates a relative path from the full path. Here's how it works:\n   - `item.value.human_readable.split('/')` splits the full path into an array of directory and file names.\n   - `.slice(-2)` takes the last two elements of this array. This typically gives us the immediate parent directory and the file name.\n   - `.join('/')` rejoins these two elements with a forward slash.\n\n   For example, if the full path is `/home/user/projects/myproject/src/file.js`, this logic will produce `src/file.js`.\n\n3. Link Creation:\n   We create an `<a>` element for each context item. The visible text is the relative path, but we store the full path in a `data-path` attribute. This allows us to send the full path to the `openFile` command when the link is clicked.\n\n4. Event Handling:\n   Instead of inline event handlers, we now add a click event listener to each link as we create it. We also add a global click event listener to the document to handle any dynamically added links.\n\n5. Opening Files:\n   When a link is clicked, it sends a message to the extension with the `openFile` command and the full path of the file. The `handleOpenFile` method in the extension then uses this full path to open the file.\n\nThis approach maintains the user-friendly display of relative paths while still allowing the extension to open the correct file using its full path. It also complies with VS Code's strict Content Security Policy by avoiding inline event handlers.",
          "model": "claude-3.5-sonnet",
          "timestamp": "2024-09-30T05:58:32.649Z",
          "context": [
            {
              "context_type": "file",
              "key": "efcbb890-8b6a-4b42-83e9-52076d05cc0d",
              "value": {
                "human_readable": "/Users/alex/Documents/GitHub/gait-copilot/src/panelview.ts",
                "uri": "/Users/alex/Documents/GitHub/gait-copilot/src/panelview.ts",
                "isCurrentFile": true
              }
            }
          ],
          "kv_store": {
            "file_paths": [
              "src/panelview.ts"
            ]
          }
        },
        {
          "id": "ce92c2da-5dd5-434c-82db-f3475c205555",
          "messageText": "Get the path relative to the workspace folder instead",
          "responseText": "Certainly! Let's modify the code to get the path relative to the workspace folder. This approach will provide a more consistent and useful relative path, especially for projects with complex directory structures. Here's how we can implement this:\n\n```typescript:src/panelview.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\n\nexport class PanelViewProvider implements vscode.WebviewViewProvider {\n    // ... existing code ...\n\n    private getHtmlForWebview(webview: vscode.Webview): string {\n        const nonce = getNonce();\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n\n        return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<!-- ... existing HTML ... -->\n<script nonce=\"${nonce}\">\n    // ... existing JavaScript ...\n\n    window.addEventListener('message', event => {\n        const message = event.data;\n        if (message.type === 'update') {\n            // ... existing code ...\n\n            if (messageEntry.context && Array.isArray(messageEntry.context) && messageEntry.context.length > 0) {\n                const contextDiv = document.createElement('div');\n                contextDiv.className = 'context';\n                contextDiv.style.fontSize = '0.8em';\n                contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                const humanReadableContext = messageEntry.context\n                    .filter(item => item && typeof item === 'object' && item.value && typeof item.value === 'object' && typeof item.value.human_readable === 'string')\n                    .map(item => {\n                        const fullPath = item.value.human_readable;\n                        let relativePath = fullPath;\n                        \n                        // Get the path relative to the workspace folder\n                        if (${JSON.stringify(workspaceFolder?.uri.fsPath)}) {\n                            relativePath = fullPath.replace(${JSON.stringify(workspaceFolder?.uri.fsPath + path.sep)}, '');\n                        }\n\n                        const link = document.createElement('a');\n                        link.href = '#';\n                        link.textContent = escapeHtml(relativePath);\n                        link.dataset.path = fullPath;\n                        link.addEventListener('click', (e) => {\n                            e.preventDefault();\n                            vscode.postMessage({command: 'openFile', path: e.target.dataset.path});\n                        });\n                        return link.outerHTML;\n                    })\n                    .join(', ');\n                if (humanReadableContext) {\n                    contextDiv.innerHTML = \\`<strong>Context:</strong> \\${humanReadableContext}\\`;\n                    messageContainer.appendChild(contextDiv);\n                }\n            }\n\n            // ... existing code ...\n        }\n    });\n\n    // ... existing JavaScript ...\n</script>\n</body>\n</html>\n        `;\n    }\n\n    // ... existing code ...\n}\n```\n\nHere's what we've changed and why:\n\n1. Workspace Folder Path:\n   We get the workspace folder path at the beginning of the `getHtmlForWebview` method. This allows us to use it in our JavaScript code.\n\n2. Relative Path Calculation:\n   ```javascript\n   let relativePath = fullPath;\n   if (${JSON.stringify(workspaceFolder?.uri.fsPath)}) {\n       relativePath = fullPath.replace(${JSON.stringify(workspaceFolder?.uri.fsPath + path.sep)}, '');\n   }\n   ```\n   This code calculates the relative path by removing the workspace folder path from the full path. We use `JSON.stringify` to properly escape the workspace folder path when injecting it into the JavaScript code.\n\n3. Path Separator:\n   We add `path.sep` to the workspace folder path before replacing it. This ensures we remove the entire workspace folder path, including the trailing separator.\n\n4. Fallback to Full Path:\n   If for some reason we can't calculate the relative path (e.g., if there's no workspace folder), we fall back to using the full path.\n\n5. Link Creation:\n   We create the link using the relative path as the visible text, but we still store the full path in the `data-path` attribute. This ensures that when the link is clicked, we send the full path to the `openFile` command.\n\nThis approach will display paths relative to the workspace root, which is typically more useful and consistent across different parts of a project. For example, if your workspace is `/home/user/projects/myproject` and the full path is `/home/user/projects/myproject/src/components/Button.js`, it will display as `src/components/Button.js`.\n\nRemember to keep the `handleOpenFile` method as it was, using the full path to open the file:\n\n```typescript\nprivate async handleOpenFile(filePath: string) {\n    try {\n        const fullPath = vscode.Uri.file(filePath);\n        const document = await vscode.workspace.openTextDocument(fullPath);\n        await vscode.window.showTextDocument(document);\n    } catch (error: any) {\n        vscode.window.showErrorMessage(`Failed to open file: ${error.message}`);\n    }\n}\n```\n\nThis ensures that the correct file is opened, regardless of how the path is displayed in the webview.",
          "model": "claude-3.5-sonnet",
          "timestamp": "2024-09-30T05:58:32.649Z",
          "context": [
            {
              "context_type": "file",
              "key": "906021a7-22d5-41c2-b777-f5dda07184f3",
              "value": {
                "human_readable": "/Users/alex/Documents/GitHub/gait-copilot/src/panelview.ts",
                "uri": "/Users/alex/Documents/GitHub/gait-copilot/src/panelview.ts",
                "isCurrentFile": true
              }
            }
          ],
          "kv_store": {
            "file_paths": [
              ".gait/state.json"
            ]
          }
        },
        {
          "id": "1544d0ec-ffdf-4351-80c1-18cf773af47d",
          "messageText": "I am getting unexpected token: {",
          "responseText": "I apologize for the confusion. The error you're seeing is likely due to the way we're trying to inject JavaScript code into the HTML template string. Let's modify the approach to avoid this issue. We'll move the path calculation logic to the TypeScript side and pass it to the webview as data. Here's the corrected version:\n\n```typescript:src/panelview.ts\nimport * as vscode from 'vscode';\nimport * as path from 'path';\n\nexport class PanelViewProvider implements vscode.WebviewViewProvider {\n    // ... existing code ...\n\n    private getHtmlForWebview(webview: vscode.Webview): string {\n        const nonce = getNonce();\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n\n        return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<!-- ... existing HTML ... -->\n<script nonce=\"${nonce}\">\n    const vscode = acquireVsCodeApi();\n    const workspaceFolderPath = ${JSON.stringify(workspaceFolder?.uri.fsPath)};\n\n    // ... existing JavaScript ...\n\n    window.addEventListener('message', event => {\n        const message = event.data;\n        if (message.type === 'update') {\n            // ... existing code ...\n\n            if (messageEntry.context && Array.isArray(messageEntry.context) && messageEntry.context.length > 0) {\n                const contextDiv = document.createElement('div');\n                contextDiv.className = 'context';\n                contextDiv.style.fontSize = '0.8em';\n                contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                const humanReadableContext = messageEntry.context\n                    .filter(item => item && typeof item === 'object' && item.value && typeof item.value === 'object' && typeof item.value.human_readable === 'string')\n                    .map(item => {\n                        const fullPath = item.value.human_readable;\n                        let relativePath = fullPath;\n                        \n                        if (workspaceFolderPath && fullPath.startsWith(workspaceFolderPath)) {\n                            relativePath = fullPath.slice(workspaceFolderPath.length + 1); // +1 to remove the leading slash\n                        }\n\n                        const link = document.createElement('a');\n                        link.href = '#';\n                        link.textContent = escapeHtml(relativePath);\n                        link.dataset.path = fullPath;\n                        link.addEventListener('click', (e) => {\n                            e.preventDefault();\n                            vscode.postMessage({command: 'openFile', path: e.target.dataset.path});\n                        });\n                        return link.outerHTML;\n                    })\n                    .join(', ');\n                if (humanReadableContext) {\n                    contextDiv.innerHTML = \\`<strong>Context:</strong> \\${humanReadableContext}\\`;\n                    messageContainer.appendChild(contextDiv);\n                }\n            }\n\n            // ... existing code ...\n        }\n    });\n\n    // ... existing JavaScript ...\n</script>\n</body>\n</html>\n        `;\n    }\n\n    // ... existing code ...\n}\n```\n\nHere's what we've changed:\n\n1. We're now passing the workspace folder path as a JavaScript variable:\n   ```javascript\n   const workspaceFolderPath = ${JSON.stringify(workspaceFolder?.uri.fsPath)};\n   ```\n\n2. The relative path calculation is now done entirely in JavaScript:\n   ```javascript\n   if (workspaceFolderPath && fullPath.startsWith(workspaceFolderPath)) {\n       relativePath = fullPath.slice(workspaceFolderPath.length + 1);\n   }\n   ```\n\n3. We're using `startsWith()` to check if the full path starts with the workspace folder path, which is a more reliable way to determine if it's within the workspace.\n\n4. We use `slice()` to remove the workspace folder path from the beginning of the full path, giving us the relative path.\n\nThese changes should resolve the \"unexpected token\" error and correctly calculate the relative paths. The rest of the functionality remains the same:\n\n- The visible text of the link is the relative path (or full path if it's outside the workspace).\n- The `data-path` attribute of the link still contains the full path.\n- Clicking the link will send the full path to the `openFile` command.\n\nRemember to keep the `handleOpenFile` method as it was, using the full path to open the file. This approach should work correctly and avoid any JavaScript syntax errors in the webview.",
          "model": "claude-3.5-sonnet",
          "timestamp": "2024-09-30T05:58:32.649Z",
          "context": [
            {
              "context_type": "file",
              "key": "35cd557f-a942-4951-8b17-082ed5153f29",
              "value": {
                "human_readable": "/Users/alex/Documents/GitHub/gait-copilot/src/panelview.ts",
                "uri": "/Users/alex/Documents/GitHub/gait-copilot/src/panelview.ts",
                "isCurrentFile": true
              }
            }
          ],
          "kv_store": {
            "file_paths": [
              ".gait/state.json"
            ]
          }
        }
      ],
      "kv_store": {}
    }
  ],
  "inlineChats": [
    {
      "inline_chat_id": "26b7a2d6-f654-4199-8f45-6fe16f63d3c6",
      "file_diff": [
        {
          "file_path": "src/identify_user.ts",
          "before_content": "",
          "after_content": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        \n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            \n            context.globalState.update('posthog_id', hashedEmail);\n            context.globalState.update('email', trimmedEmail);\n            \n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n",
          "diffs": [
            {
              "count": 27,
              "added": true,
              "removed": false,
              "value": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        \n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            \n            context.globalState.update('posthog_id', hashedEmail);\n            context.globalState.update('email', trimmedEmail);\n            \n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n"
            }
          ]
        }
      ],
      "selection": null,
      "timestamp": "2024-10-03T02:06:04.681Z",
      "prompt": "use simplegit and ",
      "parent_inline_chat_id": null
    },
    {
      "inline_chat_id": "754e7e8a-e472-49b8-a340-d81d9ab29fae",
      "file_diff": [
        {
          "file_path": "src/panelgit.ts",
          "before_content": "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport { StashedState, PanelChat, isStashedState, isPanelChat } from './types';\nimport { InlineChatInfo } from './inline';\nimport { readStashedState } from './stashedState'; // Ensure this does not use gzip\nimport { execFile } from 'child_process';\nimport { promisify } from 'util';\n\nconst SCHEMA_VERSION = '1.0';\n\nexport type CommitData = {\n    commitHash: string;\n    date: Date;\n    commitMessage: string;\n    author: string;\n    panelChats: PanelChat[];\n    inlineChats: InlineChatInfo[];\n};\n\nexport type UncommittedData = {\n    panelChats: PanelChat[];\n    inlineChats: InlineChatInfo[];\n};\n\nexport type GitHistoryData = {\n    commits: CommitData[];\n    added: UncommittedData | null;\n    uncommitted: UncommittedData | null;\n};\n\nenum LogLevel {\n    INFO,\n    WARN,\n    ERROR\n}\n\nconst CURRENT_LOG_LEVEL = LogLevel.INFO;\n\n/**\n * Logs messages based on the specified log level.\n * @param message - The message to log.\n * @param level - The severity level of the log.\n */\nfunction log(message: string, level: LogLevel = LogLevel.INFO) {\n    if (level >= CURRENT_LOG_LEVEL) {\n        switch (level) {\n            case LogLevel.INFO:\n                console.log(message);\n            case LogLevel.WARN:\n                console.warn(message);\n                break;\n            case LogLevel.ERROR:\n                console.error(message);\n                break;\n        }\n    }\n}\n\nconst execFileAsync = promisify(execFile);\n\n/**\n * Executes a Git command and returns the output as a string.\n * @param args - Array of Git command arguments.\n * @param repoPath - The path to the Git repository.\n * @returns A Promise resolving to a string containing the command output.\n */\nasync function gitShowString(args: string[], repoPath: string): Promise<string> {\n    try {\n        const { stdout } = await execFileAsync('git', args, { cwd: repoPath });\n        return stdout;\n    } catch (error) {\n        throw new Error(`Git command failed: ${(error as Error).message}`);\n    }\n}\n\n\n/**\n * Processes a single commit's state.json and extracts active PanelChats and Messages.\n * @param parsedContent - The parsed StashedState from the commit.\n * @param currentMessageIds - Set of active message IDs.\n * @param currentInlineChatIds - Set of active inline chat IDs.\n * @param seenMessageIds - Set to track already processed message IDs.\n * @param commitData - The CommitData object to populate.\n * @param commitHash - The hash of the current commit (for logging purposes).\n */\nfunction processCommit(\n    parsedContent: StashedState,\n    currentMessageIds: Set<string>,\n    currentInlineChatIds: Set<string>,\n    seenMessageIds: Set<string>,\n    commitData: CommitData,\n    commitHash: string\n) {\n    log(`Processing Commit Hash: ${commitHash}`, LogLevel.INFO);\n\n    const { deletedChats } = parsedContent;\n    const deletedPanelChatIds = new Set(deletedChats.deletedPanelChatIDs);\n    const deletedMessageIds = new Set(deletedChats.deletedMessageIDs);\n\n    // Process Inline Chats\n    if (Array.isArray(parsedContent.inlineChats)) {\n        for (const inlineChat of parsedContent.inlineChats) {\n            const inlineChatId = inlineChat.inline_chat_id;\n            if (currentInlineChatIds.has(inlineChatId)) {\n                commitData.inlineChats.push(inlineChat);\n            }\n        }\n    }\n\n    // Process Panel Chats\n    for (const panelChat of parsedContent.panelChats) {\n        const panelChatId = panelChat.id;\n\n        // Skip deleted PanelChats\n        if (deletedPanelChatIds.has(panelChatId)) {\n            log(`PanelChat ID ${panelChatId} has been deleted in commit ${commitHash}. Excluding from processing.`, LogLevel.INFO);\n            continue;\n        }\n\n        // Retrieve or initialize existing PanelChat in commitData\n        let existingPanelChat = commitData.panelChats.find(pc => pc.id === panelChatId);\n        if (!existingPanelChat) {\n            existingPanelChat = { ...panelChat, messages: [], kv_store: {} };\n            commitData.panelChats.push(existingPanelChat);\n            log(`Initialized PanelChat ID ${panelChatId} in commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process Messages within PanelChat\n        for (const message of panelChat.messages) {\n            const messageId = message.id;\n\n            if (currentMessageIds.has(messageId) && !seenMessageIds.has(messageId) && !deletedMessageIds.has(messageId)) {\n                existingPanelChat.messages.push(message);\n                log(`Added Message ID ${messageId} from PanelChat ${panelChatId} in commit ${commitHash}.`, LogLevel.INFO);\n                seenMessageIds.add(messageId);\n            } else {\n                if (!currentMessageIds.has(messageId)) {\n                    log(`Message ID ${messageId} has been deleted in the current state. Excluding from commit ${commitHash}.`, LogLevel.INFO);\n                } else {\n                    log(`Message ID ${messageId} has already been processed. Skipping.`, LogLevel.INFO);\n                }\n            }\n        }\n    }\n}\n\n\n\n/**\n * Aggregates active PanelChat and InlineChat IDs from the current stashed state.\n * @param parsedCurrent - The current StashedState.\n * @returns An object containing sets of active PanelChat and Message IDs, and active InlineChat IDs.\n */\nfunction aggregateCurrentIds(parsedCurrent: StashedState) {\n    const currentMessageIds: Set<string> = new Set();\n    const currentPanelChatIds: Set<string> = new Set();\n    const currentInlineChatIds: Set<string> = new Set();\n\n    const { deletedChats, panelChats, inlineChats } = parsedCurrent;\n    const deletedPanelChatIds = new Set(deletedChats.deletedPanelChatIDs);\n    const deletedMessageIds = new Set(deletedChats.deletedMessageIDs);\n\n    for (const panelChat of panelChats) {\n        if (!deletedPanelChatIds.has(panelChat.id)) {\n            currentPanelChatIds.add(panelChat.id);\n            for (const message of panelChat.messages) {\n                if (!deletedMessageIds.has(message.id)) {\n                    currentMessageIds.add(message.id);\n                }\n            }\n        }\n    }\n\n    for (const inlineChat of inlineChats) {\n        currentInlineChatIds.add(inlineChat.inline_chat_id);\n    }\n\n    log(`Collected ${currentPanelChatIds.size} active PanelChat IDs, ${currentMessageIds.size} active Message IDs, and ${currentInlineChatIds.size} active InlineChat IDs.`, LogLevel.INFO);\n\n    return { currentMessageIds, currentPanelChatIds, currentInlineChatIds };\n}\n\n/**\n * Retrieves the Git history for a specific file, capturing PanelChats instead of flat messages.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to GitHistoryData containing commit history and uncommitted changes.\n */\nexport async function getGitHistory(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<GitHistoryData> {\n    const git: SimpleGit = simpleGit(repoPath);\n    log(\"Starting getGitHistory\", LogLevel.INFO);\n\n    // Ensure the file exists in the repository\n    const absoluteFilePath = path.resolve(repoPath, filePath);\n    if (!fs.existsSync(absoluteFilePath)) {\n        throw new Error(`File not found: ${absoluteFilePath}`);\n    }\n\n    // Step 1: Read and validate the current state.json\n    const parsedCurrent = readStashedState(context); \n    const { currentMessageIds, currentPanelChatIds, currentInlineChatIds } = aggregateCurrentIds(parsedCurrent);\n    const seenMessageIds: Set<string> = new Set();\n\n    // Step 2: Get the commit history for the file with --follow to track renames\n    const logArgs = ['log', '--reverse', '--follow', '--pretty=format:%H%x09%an%x09%ad%x09%s', '--', filePath];\n    let logData: string;\n\n    try {\n        logData = await git.raw(logArgs);\n        log(`Retrieved git log data successfully.`, LogLevel.INFO);\n    } catch (error) {\n        throw new Error(`Failed to retrieve git log: ${(error as Error).message}`);\n    }\n\n    const logLines = logData.split('\\n').filter(line => line.trim() !== '');\n    log(`Processing ${logLines.length} commits from git log.`, LogLevel.INFO);\n\n    const allCommitsMap: Map<string, CommitData> = new Map();\n\n    for (const line of logLines) {\n        const [commitHash, authorName, dateStr, ...commitMsgParts] = line.split('\\t');\n        const commitMessage = commitMsgParts.join('\\t');\n\n        // Get the file content at this commit using child_process\n        let fileContent: string;\n        try {\n            fileContent = await gitShowString(['show', `${commitHash}:${filePath}`], repoPath);\n            log(`Retrieved file content for commit ${commitHash}.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Could not retrieve file ${filePath} at commit ${commitHash}. Error: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Parse JSON\n        let parsedContent: StashedState;\n        try {\n            parsedContent = JSON.parse(fileContent);\n            if (!isStashedState(parsedContent)) {\n                throw new Error('Parsed content does not match StashedState structure.');\n            }\n            log(`Parsed state.json for commit ${commitHash} successfully.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Failed to parse JSON for commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            log(`Content: ${fileContent}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Initialize or retrieve existing CommitData for this commit\n        let commitData = allCommitsMap.get(commitHash);\n        if (!commitData) {\n            commitData = {\n                commitHash,\n                date: new Date(dateStr),\n                commitMessage,\n                author: authorName,\n                panelChats: [],\n                inlineChats: [],\n            };\n            allCommitsMap.set(commitHash, commitData);\n            log(`Initialized CommitData for commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process the commit's panelChats and inlineChats\n        processCommit(parsedContent, currentMessageIds, currentInlineChatIds, seenMessageIds, commitData, commitHash);\n    }\n\n    // Convert the map to an array and filter out empty commits\n    let allCommits: CommitData[] = Array.from(allCommitsMap.values())\n        .map(commit => ({\n            ...commit,\n            panelChats: commit.panelChats.filter(pc => pc.messages.length > 0)\n        }))\n        .filter(commit => commit.panelChats.length > 0);\n\n    log(`Filtered commits to exclude empty ones. Remaining commits count: ${allCommits.length}`, LogLevel.INFO);\n\n    // Step 3: Aggregate uncommitted added content\n    const allAddedPanelChats: PanelChat[] = parsedCurrent.panelChats\n        .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n        .map(pc => ({\n            ...pc,\n            messages: pc.messages.filter(msg => \n                !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                !seenMessageIds.has(msg.id)\n            )\n        }))\n        .filter(pc => pc.messages.length > 0);\n\n    const added: UncommittedData = {\n        panelChats: allAddedPanelChats,\n        inlineChats: parsedCurrent.inlineChats.filter(ic => currentInlineChatIds.has(ic.inline_chat_id))\n    };\n\n    // Step 4: Handle uncommitted changes\n    let uncommitted: UncommittedData | null = null;\n    try {\n        const currentUncommittedContent = context.workspaceState.get<PanelChat[]>('currentPanelChats') || [];\n\n        if (!Array.isArray(currentUncommittedContent) || !currentUncommittedContent.every(isPanelChat)) {\n            throw new Error('Parsed content does not match PanelChat structure.');\n        }\n\n        const allCurrentPanelChats: PanelChat[] = currentUncommittedContent\n            .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n            .map(pc => ({\n                ...pc,\n                messages: pc.messages.filter(msg => \n                    !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                    !seenMessageIds.has(msg.id)\n                )\n            }))\n            .filter(pc => pc.messages.length > 0);\n\n        if (allCurrentPanelChats.length > 0) {\n            uncommitted = {\n                panelChats: allCurrentPanelChats,\n                inlineChats: []\n            };\n            log(`Found ${allCurrentPanelChats.length} uncommitted new panelChats.`, LogLevel.INFO);\n        } else {\n            log(\"No uncommitted new panelChats found.\", LogLevel.INFO);\n        }\n    } catch (error) {\n        log(`Warning: Failed to read current uncommitted content: ${(error as Error).message}`, LogLevel.WARN);\n    }\n\n    return {\n        commits: allCommits,\n        added: allAddedPanelChats.length > 0 ? added : null,\n        uncommitted\n    };\n}\n\n/**\n * Retrieves the Git history for a specific file that also touches a target file.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the main target file within the repository.\n * @param targetFilePath - The relative path to the additional target file within the repository.\n * @returns A Promise resolving to GitHistoryData containing commit history and uncommitted changes.\n */\nexport async function getGitHistoryThatTouchesFile(\n    context: vscode.ExtensionContext,\n    repoPath: string,\n    filePath: string,\n    targetFilePath: string\n): Promise<GitHistoryData> {\n    const git: SimpleGit = simpleGit(repoPath);\n    log(\"Starting getGitHistoryThatTouchesFile\", LogLevel.INFO);\n\n    // Ensure both files exist in the repository\n    const absoluteFilePath = path.resolve(repoPath, filePath);\n    const absoluteTargetFilePath = path.resolve(repoPath, targetFilePath);\n    if (!fs.existsSync(absoluteFilePath)) {\n        throw new Error(`File not found: ${absoluteFilePath}`);\n    }\n    if (!fs.existsSync(absoluteTargetFilePath)) {\n        throw new Error(`Target file not found: ${absoluteTargetFilePath}`);\n    }\n\n    // Step 1: Read and validate the current state.json\n    const parsedCurrent = readStashedState(context); \n    const { currentMessageIds, currentPanelChatIds, currentInlineChatIds } = aggregateCurrentIds(parsedCurrent);\n    const seenMessageIds: Set<string> = new Set();\n\n    // Step 2: Get the commit history for the main file with --follow to track renames\n    const logArgs = ['log', '--reverse', '--follow', '--pretty=format:%H%x09%an%x09%ad%x09%s', '--', filePath];\n    let logData: string;\n\n    try {\n        logData = await git.raw(logArgs);\n        log(`Retrieved git log data successfully.`, LogLevel.INFO);\n    } catch (error) {\n        throw new Error(`Failed to retrieve git log for ${filePath}: ${(error as Error).message}`);\n    }\n\n    const logLines = logData.split('\\n').filter(line => line.trim() !== '');\n    log(`Processing ${logLines.length} commits from git log.`, LogLevel.INFO);\n\n    const allCommitsMap: Map<string, CommitData> = new Map();\n\n    for (const line of logLines) {\n        const [commitHash, authorName, dateStr, ...commitMsgParts] = line.split('\\t');\n        const commitMessage = commitMsgParts.join('\\t');\n\n        // Skip commits that are solely for deletions\n        if (\n            commitMessage.startsWith('Delete message with ID') || \n            commitMessage.startsWith('Delete PanelChat with ID')\n        ) {\n            log(`Skipping deletion commit ${commitHash}: ${commitMessage}`, LogLevel.INFO);\n            continue;\n        }\n\n        // Check if this commit modifies the targetFilePath\n        let modifiesTargetFile = false;\n        try {\n            const filesChanged = await git.raw(['diff-tree', '--no-commit-id', '--name-only', '-r', commitHash]);\n            const files = filesChanged.split('\\n').map(f => f.trim());\n            modifiesTargetFile = files.includes(targetFilePath);\n            log(\n                `Commit ${commitHash} ${modifiesTargetFile ? 'modifies' : 'does not modify'} target file ${targetFilePath}.`,\n                LogLevel.INFO\n            );\n        } catch (error) {\n            log(`Warning: Failed to retrieve files changed in commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        if (!modifiesTargetFile) {\n            continue;\n        }\n\n        // Get the file content at this commit\n        let fileContent: string;\n        try {\n            fileContent = await gitShowString(['show', `${commitHash}:${filePath}`], repoPath);\n            log(`Retrieved file content for commit ${commitHash}.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Could not retrieve file ${filePath} at commit ${commitHash}. Error: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Parse JSON\n        let parsedContent: StashedState;\n        try {\n            parsedContent = JSON.parse(fileContent);\n            if (!isStashedState(parsedContent)) {\n                throw new Error('Parsed content does not match StashedState structure.');\n            }\n            log(`Parsed state.json for commit ${commitHash} successfully.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Failed to parse JSON for commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            log(`Content: ${fileContent}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Initialize or retrieve existing CommitData for this commit\n        let commitData = allCommitsMap.get(commitHash);\n        if (!commitData) {\n            commitData = {\n                commitHash,\n                date: new Date(dateStr),\n                commitMessage,\n                author: authorName,\n                panelChats: [],\n                inlineChats: [],\n            };\n            allCommitsMap.set(commitHash, commitData);\n            log(`Initialized CommitData for commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process the commit's panelChats and inlineChats\n        processCommit(parsedContent, currentMessageIds, currentInlineChatIds, seenMessageIds, commitData, commitHash);\n    }\n\n    // Convert the map to an array and filter out empty commits\n    let allCommits: CommitData[] = Array.from(allCommitsMap.values())\n        .map(commit => ({\n            ...commit,\n            panelChats: commit.panelChats.filter(pc => pc.messages.length > 0)\n        }))\n        .filter(commit => commit.panelChats.length > 0);\n\n    log(`Filtered commits to exclude empty ones. Remaining commits count: ${allCommits.length}`, LogLevel.INFO);\n\n    // Step 3: Aggregate uncommitted added content\n    const allAddedPanelChats: PanelChat[] = parsedCurrent.panelChats\n        .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n        .map(pc => ({\n            ...pc,\n            messages: pc.messages.filter(msg => \n                !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                !seenMessageIds.has(msg.id)\n            )\n        }))\n        .filter(pc => pc.messages.length > 0);\n\n    const added: UncommittedData = {\n        panelChats: allAddedPanelChats,\n        inlineChats: parsedCurrent.inlineChats.filter(ic => currentInlineChatIds.has(ic.inline_chat_id))\n    };\n\n    // Step 4: Check for uncommitted changes\n    let uncommitted: UncommittedData | null = null;\n    try {\n        const status = await git.status();\n        const isModified = [\n            status.modified,\n            status.not_added,\n            status.created\n        ].some(list => list.includes(targetFilePath));\n\n        if (isModified) {\n            log(`File ${targetFilePath} is modified. Processing uncommitted changes.`, LogLevel.INFO);\n\n            const currentUncommittedContent = context.workspaceState.get<PanelChat[]>('currentPanelChats') || [];\n\n            if (!Array.isArray(currentUncommittedContent) || !currentUncommittedContent.every(isPanelChat)) {\n                throw new Error('Parsed content does not match PanelChat structure.');\n            }\n\n            const allCurrentPanelChats: PanelChat[] = currentUncommittedContent\n                .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n                .map(pc => ({\n                    ...pc,\n                    messages: pc.messages.filter(msg => \n                        !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                        !seenMessageIds.has(msg.id)\n                    )\n                }))\n                .filter(pc => pc.messages.length > 0);\n\n            if (allCurrentPanelChats.length > 0) {\n                uncommitted = {\n                    panelChats: allCurrentPanelChats,\n                    inlineChats: []\n                };\n                log(`Found ${allCurrentPanelChats.length} uncommitted new panelChats.`, LogLevel.INFO);\n            } else {\n                log(\"No uncommitted new panelChats found.\", LogLevel.INFO);\n            }\n        }\n    } catch (error) {\n        log(`Warning: Failed to process uncommitted changes: ${(error as Error).message}`, LogLevel.WARN);\n    }\n\n    return {\n        commits: allCommits,\n        added: allAddedPanelChats.length > 0 ? added : null,\n        uncommitted\n    };\n}\n\n/**\n * Maps message IDs to their respective commit information.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to a Map where keys are message IDs and values are CommitData.\n */\nexport async function getIdToCommitInfo(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<Map<string, CommitData>> {\n    const gitHistory = await getGitHistory(context, repoPath, filePath);\n    const idToCommitInfo = new Map<string, CommitData>();\n\n    for (const commit of gitHistory.commits) {\n        for (const panelChat of commit.panelChats) {\n            for (const message of panelChat.messages) {\n                idToCommitInfo.set(message.id, commit);\n            }\n        }\n    }\n\n    return idToCommitInfo;\n}\n\n/**\n * Maps inline chat IDs to their respective commit information.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to a Map where keys are inline chat IDs and values are CommitData.\n */\nexport async function getInlineChatIdToCommitInfo(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<Map<string, CommitData>> {\n    const gitHistory = await getGitHistory(context, repoPath, filePath);\n    const idToCommitInfo = new Map<string, CommitData>();\n\n    for (const commit of gitHistory.commits) {\n        for (const inlineChat of commit.inlineChats) {\n            idToCommitInfo.set(inlineChat.inline_chat_id, commit);\n        }\n    }\n\n    return idToCommitInfo;\n}\n",
          "after_content": "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport { StashedState, PanelChat, isStashedState, isPanelChat } from './types';\nimport { InlineChatInfo } from './inline';\nimport { readStashedState } from './stashedState'; // Ensure this does not use gzip\nimport { execFile } from 'child_process';\nimport { promisify } from 'util';\n\nconst SCHEMA_VERSION = '1.0';\n\nexport type CommitData = {\n    commitHash: string;\n    date: Date;\n    commitMessage: string;\n    author: string;\n    panelChats: PanelChat[];\n    inlineChats: InlineChatInfo[];\n};\n\nexport type UncommittedData = {\n    panelChats: PanelChat[];\n    inlineChats: InlineChatInfo[];\n};\n\nexport type GitHistoryData = {\n    commits: CommitData[];\n    added: UncommittedData | null;\n    uncommitted: UncommittedData | null;\n};\n\nenum LogLevel {\n    INFO,\n    WARN,\n    ERROR\n}\n\nconst CURRENT_LOG_LEVEL = LogLevel.INFO;\n\n/**\n * Logs messages based on the specified log level.\n * @param message - The message to log.\n * @param level - The severity level of the log.\n */\nfunction log(message: string, level: LogLevel = LogLevel.INFO) {\n    if (level >= CURRENT_LOG_LEVEL) {\n        switch (level) {\n            case LogLevel.INFO:\n                console.log(message);\n            case LogLevel.WARN:\n                console.warn(message);\n                break;\n            case LogLevel.ERROR:\n                console.error(message);\n                break;\n        }\n    }\n}\n\nconst execFileAsync = promisify(execFile);\n\n/**\n * Executes a Git command and returns the output as a string.\n * @param args - Array of Git command arguments.\n * @param repoPath - The path to the Git repository.\n * @returns A Promise resolving to a string containing the command output.\n */\nasync function gitShowString(args: string[], repoPath: string): Promise<string> {\n    try {\n        const { stdout } = await execFileAsync('git', args, { cwd: repoPath });\n        return stdout;\n    } catch (error) {\n        throw new Error(`Git command failed: ${(error as Error).message}`);\n    }\n}\n\n\n/**\n * Processes a single commit's state.json and extracts active PanelChats and Messages.\n * @param parsedContent - The parsed StashedState from the commit.\n * @param currentMessageIds - Set of active message IDs.\n * @param currentInlineChatIds - Set of active inline chat IDs.\n * @param seenMessageIds - Set to track already processed message IDs.\n * @param commitData - The CommitData object to populate.\n * @param commitHash - The hash of the current commit (for logging purposes).\n */\nfunction processCommit(\n    parsedContent: StashedState,\n    currentMessageIds: Set<string>,\n    currentInlineChatIds: Set<string>,\n    seenMessageIds: Set<string>,\n    commitData: CommitData,\n    commitHash: string\n) {\n    log(`Processing Commit Hash: ${commitHash}`, LogLevel.INFO);\n\n    const { deletedChats } = parsedContent;\n    const deletedPanelChatIds = new Set(deletedChats.deletedPanelChatIDs);\n    const deletedMessageIds = new Set(deletedChats.deletedMessageIDs);\n\n    // Process Inline Chats\n    if (Array.isArray(parsedContent.inlineChats)) {\n        for (const inlineChat of parsedContent.inlineChats) {\n            const inlineChatId = inlineChat.inline_chat_id;\n            if (currentInlineChatIds.has(inlineChatId)) {\n                commitData.inlineChats.push(inlineChat);\n            }\n        }\n    }\n\n    // Process Panel Chats\n    for (const panelChat of parsedContent.panelChats) {\n        const panelChatId = panelChat.id;\n\n        // Skip deleted PanelChats\n        if (deletedPanelChatIds.has(panelChatId)) {\n            log(`PanelChat ID ${panelChatId} has been deleted in commit ${commitHash}. Excluding from processing.`, LogLevel.INFO);\n            continue;\n        }\n\n        // Retrieve or initialize existing PanelChat in commitData\n        let existingPanelChat = commitData.panelChats.find(pc => pc.id === panelChatId);\n        if (!existingPanelChat) {\n            existingPanelChat = { ...panelChat, messages: [], kv_store: {} };\n            commitData.panelChats.push(existingPanelChat);\n            log(`Initialized PanelChat ID ${panelChatId} in commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process Messages within PanelChat\n        for (const message of panelChat.messages) {\n            const messageId = message.id;\n\n            if (currentMessageIds.has(messageId) && !seenMessageIds.has(messageId) && !deletedMessageIds.has(messageId)) {\n                existingPanelChat.messages.push(message);\n                log(`Added Message ID ${messageId} from PanelChat ${panelChatId} in commit ${commitHash}.`, LogLevel.INFO);\n                seenMessageIds.add(messageId);\n            } else {\n                if (!currentMessageIds.has(messageId)) {\n                    log(`Message ID ${messageId} has been deleted in the current state. Excluding from commit ${commitHash}.`, LogLevel.INFO);\n                } else {\n                    log(`Message ID ${messageId} has already been processed. Skipping.`, LogLevel.INFO);\n                }\n            }\n        }\n    }\n}\n\n\n\n/**\n * Aggregates active PanelChat and InlineChat IDs from the current stashed state.\n * @param parsedCurrent - The current StashedState.\n * @returns An object containing sets of active PanelChat and Message IDs, and active InlineChat IDs.\n */\nfunction aggregateCurrentIds(parsedCurrent: StashedState) {\n    const currentMessageIds: Set<string> = new Set();\n    const currentPanelChatIds: Set<string> = new Set();\n    const currentInlineChatIds: Set<string> = new Set();\n\n    const { deletedChats, panelChats, inlineChats } = parsedCurrent;\n    const deletedPanelChatIds = new Set(deletedChats.deletedPanelChatIDs);\n    const deletedMessageIds = new Set(deletedChats.deletedMessageIDs);\n\n    for (const panelChat of panelChats) {\n        if (!deletedPanelChatIds.has(panelChat.id)) {\n            currentPanelChatIds.add(panelChat.id);\n            for (const message of panelChat.messages) {\n                if (!deletedMessageIds.has(message.id)) {\n                    currentMessageIds.add(message.id);\n                }\n            }\n        }\n    }\n\n    for (const inlineChat of inlineChats) {\n        currentInlineChatIds.add(inlineChat.inline_chat_id);\n    }\n\n    log(`Collected ${currentPanelChatIds.size} active PanelChat IDs, ${currentMessageIds.size} active Message IDs, and ${currentInlineChatIds.size} active InlineChat IDs.`, LogLevel.INFO);\n\n    return { currentMessageIds, currentPanelChatIds, currentInlineChatIds };\n}\n\n/**\n * Retrieves the Git history for a specific file, capturing PanelChats instead of flat messages.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to GitHistoryData containing commit history and uncommitted changes.\n */\nexport async function getGitHistory(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<GitHistoryData> {\n    const git: SimpleGit = simpleGit(repoPath);\n    log(\"Starting getGitHistory\", LogLevel.INFO);\n\n    // Ensure the file exists in the repository\n    const absoluteFilePath = path.resolve(repoPath, filePath);\n    if (!fs.existsSync(absoluteFilePath)) {\n        throw new Error(`File not found: ${absoluteFilePath}`);\n    }\n\n    // Step 1: Read and validate the current state.json\n    const parsedCurrent = readStashedState(context); \n    const { currentMessageIds, currentPanelChatIds, currentInlineChatIds } = aggregateCurrentIds(parsedCurrent);\n    const seenMessageIds: Set<string> = new Set();\n\n    // Step 2: Get the commit history for the file with --follow to track renames\n    const logArgs = ['log', '--reverse', '--follow', '--pretty=format:%H%x09%an%x09%ad%x09%s', '--', filePath];\n    let logData: string;\n\n    try {\n        logData = await git.raw(logArgs);\n        log(`Retrieved git log data successfully.`, LogLevel.INFO);\n    } catch (error) {\n        throw new Error(`Failed to retrieve git log: ${(error as Error).message}`);\n    }\n\n    const logLines = logData.split('\\n').filter(line => line.trim() !== '');\n    log(`Processing ${logLines.length} commits from git log.`, LogLevel.INFO);\n\n    const allCommitsMap: Map<string, CommitData> = new Map();\n\n    for (const line of logLines) {\n        const [commitHash, authorName, dateStr, ...commitMsgParts] = line.split('\\t');\n        const commitMessage = commitMsgParts.join('\\t');\n\n        // Get the file content at this commit using child_process\n        let fileContent: string;\n        try {\n            fileContent = await gitShowString(['show', `${commitHash}:${filePath}`], repoPath);\n            log(`Retrieved file content for commit ${commitHash}.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Could not retrieve file ${filePath} at commit ${commitHash}. Error: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Parse JSON\n        let parsedContent: StashedState;\n        try {\n            parsedContent = JSON.parse(fileContent);\n            if (!isStashedState(parsedContent)) {\n                throw new Error('Parsed content does not match StashedState structure.');\n            }\n            log(`Parsed state.json for commit ${commitHash} successfully.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Failed to parse JSON for commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            log(`Content: ${fileContent}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Initialize or retrieve existing CommitData for this commit\n        let commitData = allCommitsMap.get(commitHash);\n        if (!commitData) {\n            commitData = {\n                commitHash,\n                date: new Date(dateStr),\n                commitMessage,\n                author: authorName,\n                panelChats: [],\n                inlineChats: [],\n            };\n            allCommitsMap.set(commitHash, commitData);\n            log(`Initialized CommitData for commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process the commit's panelChats and inlineChats\n        processCommit(parsedContent, currentMessageIds, currentInlineChatIds, seenMessageIds, commitData, commitHash);\n    }\n\n    // Convert the map to an array and filter out empty commits\n    let allCommits: CommitData[] = Array.from(allCommitsMap.values())\n        .map(commit => ({\n            ...commit,\n            panelChats: commit.panelChats.filter(pc => pc.messages.length > 0)\n        }))\n        .filter(commit => commit.panelChats.length > 0);\n\n    log(`Filtered commits to exclude empty ones. Remaining commits count: ${allCommits.length}`, LogLevel.INFO);\n\n    // Step 3: Aggregate uncommitted added content\n    const allAddedPanelChats: PanelChat[] = parsedCurrent.panelChats\n        .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n        .map(pc => ({\n            ...pc,\n            messages: pc.messages.filter(msg => \n                !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                !seenMessageIds.has(msg.id)\n            )\n        }))\n        .filter(pc => pc.messages.length > 0);\n\n    const added: UncommittedData = {\n        panelChats: allAddedPanelChats,\n        inlineChats: parsedCurrent.inlineChats.filter(ic => currentInlineChatIds.has(ic.inline_chat_id))\n    };\n\n    // Step 4: Handle uncommitted changes\n    let uncommitted: UncommittedData | null = null;\n    try {\n        const currentUncommittedContent = context.workspaceState.get<PanelChat[]>('currentPanelChats') || [];\n\n        if (!Array.isArray(currentUncommittedContent) || !currentUncommittedContent.every(isPanelChat)) {\n            throw new Error('Parsed content does not match PanelChat structure.');\n        }\n\n        const allCurrentPanelChats: PanelChat[] = currentUncommittedContent\n            .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n            .map(pc => ({\n                ...pc,\n                messages: pc.messages.filter(msg => \n                    !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                    !seenMessageIds.has(msg.id)\n                )\n            }))\n            .filter(pc => pc.messages.length > 0);\n\n        if (allCurrentPanelChats.length > 0) {\n            uncommitted = {\n                panelChats: allCurrentPanelChats,\n                inlineChats: []\n            };\n            log(`Found ${allCurrentPanelChats.length} uncommitted new panelChats.`, LogLevel.INFO);\n        } else {\n            log(\"No uncommitted new panelChats found.\", LogLevel.INFO);\n        }\n    } catch (error) {\n        log(`Warning: Failed to read current uncommitted content: ${(error as Error).message}`, LogLevel.WARN);\n    }\n\n    return {\n        commits: allCommits,\n        added: allAddedPanelChats.length > 0 ? added : null,\n        uncommitted\n    };\n}\n\n/**\n * Retrieves the Git history for a specific file that also touches a target file.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the main target file within the repository.\n * @param targetFilePath - The relative path to the additional target file within the repository.\n * @returns A Promise resolving to GitHistoryData containing commit history and uncommitted changes.\n */\nexport async function getGitHistoryThatTouchesFile(\n    context: vscode.ExtensionContext,\n    repoPath: string,\n    filePath: string,\n    targetFilePath: string\n): Promise<GitHistoryData> {\n    const git: SimpleGit = simpleGit(repoPath);\n    log(\"Starting getGitHistoryThatTouchesFile\", LogLevel.INFO);\n\n    // Ensure both files exist in the repository\n    const absoluteFilePath = path.resolve(repoPath, filePath);\n    const absoluteTargetFilePath = path.resolve(repoPath, targetFilePath);\n    if (!fs.existsSync(absoluteFilePath)) {\n        throw new Error(`File not found: ${absoluteFilePath}`);\n    }\n    if (!fs.existsSync(absoluteTargetFilePath)) {\n        throw new Error(`Target file not found: ${absoluteTargetFilePath}`);\n    }\n\n    // Step 1: Read and validate the current state.json\n    const parsedCurrent = readStashedState(context); \n    const { currentMessageIds, currentPanelChatIds, currentInlineChatIds } = aggregateCurrentIds(parsedCurrent);\n    const seenMessageIds: Set<string> = new Set();\n\n    // Step 2: Get the commit history for the main file with --follow to track renames\n    const logArgs = ['log', '--reverse', '--follow', '--pretty=format:%H%x09%an%x09%ad%x09%s', '--', filePath];\n    let logData: string;\n\n    try {\n        logData = await git.raw(logArgs);\n        log(`Retrieved git log data successfully.`, LogLevel.INFO);\n    } catch (error) {\n        throw new Error(`Failed to retrieve git log for ${filePath}: ${(error as Error).message}`);\n    }\n\n    const logLines = logData.split('\\n').filter(line => line.trim() !== '');\n    log(`Processing ${logLines.length} commits from git log.`, LogLevel.INFO);\n\n    const allCommitsMap: Map<string, CommitData> = new Map();\n\n    for (const line of logLines) {\n        const [commitHash, authorName, dateStr, ...commitMsgParts] = line.split('\\t');\n        const commitMessage = commitMsgParts.join('\\t');\n\n        // Skip commits that are solely for deletions\n        if (\n            commitMessage.startsWith('Delete message with ID') || \n            commitMessage.startsWith('Delete PanelChat with ID')\n        ) {\n            log(`Skipping deletion commit ${commitHash}: ${commitMessage}`, LogLevel.INFO);\n            continue;\n        }\n\n        // Check if this commit modifies the targetFilePath\n        let modifiesTargetFile = false;\n        try {\n            const filesChanged = await git.raw(['diff-tree', '--no-commit-id', '--name-only', '-r', commitHash]);\n            const files = filesChanged.split('\\n').map(f => f.trim());\n            modifiesTargetFile = files.includes(targetFilePath);\n            log(\n                `Commit ${commitHash} ${modifiesTargetFile ? 'modifies' : 'does not modify'} target file ${targetFilePath}.`,\n                LogLevel.INFO\n            );\n        } catch (error) {\n            log(`Warning: Failed to retrieve files changed in commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        if (!modifiesTargetFile) {\n            continue;\n        }\n\n        // Get the file content at this commit\n        let fileContent: string;\n        try {\n            fileContent = await gitShowString(['show', `${commitHash}:${filePath}`], repoPath);\n            log(`Retrieved file content for commit ${commitHash}.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Could not retrieve file ${filePath} at commit ${commitHash}. Error: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Parse JSON\n        let parsedContent: StashedState;\n        try {\n            parsedContent = JSON.parse(fileContent);\n            if (!isStashedState(parsedContent)) {\n                throw new Error('Parsed content does not match StashedState structure.');\n            }\n            log(`Parsed state.json for commit ${commitHash} successfully.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Failed to parse JSON for commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            log(`Content: ${fileContent}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Initialize or retrieve existing CommitData for this commit\n        let commitData = allCommitsMap.get(commitHash);\n        if (!commitData) {\n            commitData = {\n                commitHash,\n                date: new Date(dateStr),\n                commitMessage,\n                author: authorName,\n                panelChats: [],\n                inlineChats: [],\n            };\n            allCommitsMap.set(commitHash, commitData);\n            log(`Initialized CommitData for commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process the commit's panelChats and inlineChats\n        processCommit(parsedContent, currentMessageIds, currentInlineChatIds, seenMessageIds, commitData, commitHash);\n    }\n\n    // Convert the map to an array and filter out empty commits\n    let allCommits: CommitData[] = Array.from(allCommitsMap.values())\n        .map(commit => ({\n            ...commit,\n            panelChats: commit.panelChats.filter(pc => pc.messages.length > 0)\n        }))\n        .filter(commit => commit.panelChats.length > 0);\n\n    log(`Filtered commits to exclude empty ones. Remaining commits count: ${allCommits.length}`, LogLevel.INFO);\n\n    // Step 3: Aggregate uncommitted added content\n    const allAddedPanelChats: PanelChat[] = parsedCurrent.panelChats\n        .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n        .map(pc => ({\n            ...pc,\n            messages: pc.messages.filter(msg => \n                !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                !seenMessageIds.has(msg.id)\n            )\n        }))\n        .filter(pc => pc.messages.length > 0);\n\n    const added: UncommittedData = {\n        panelChats: allAddedPanelChats,\n        inlineChats: parsedCurrent.inlineChats.filter(ic => currentInlineChatIds.has(ic.inline_chat_id))\n    };\n\n    // Step 4: Check for uncommitted changes\n    let uncommitted: UncommittedData | null = null;\n    try {\n        const status = await git.status();\n        const isModified = [\n            status.modified,\n            status.not_added,\n            status.created\n        ].some(list => list.includes(targetFilePath));\n\n        if (isModified) {\n            log(`File ${targetFilePath} is modified. Processing uncommitted changes.`, LogLevel.INFO);\n\n            const currentUncommittedContent = context.workspaceState.get<PanelChat[]>('currentPanelChats') || [];\n\n            if (!Array.isArray(currentUncommittedContent) || !currentUncommittedContent.every(isPanelChat)) {\n                throw new Error('Parsed content does not match PanelChat structure.');\n            }\n\n            const allCurrentPanelChats: PanelChat[] = currentUncommittedContent\n                .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n                .map(pc => ({\n                    ...pc,\n                    messages: pc.messages.filter(msg => \n                        !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                        !seenMessageIds.has(msg.id)\n                    )\n                }))\n                .filter(pc => pc.messages.length > 0);\n\n            if (allCurrentPanelChats.length > 0) {\n                uncommitted = {\n                    panelChats: allCurrentPanelChats,\n                    inlineChats: []\n                };\n                log(`Found ${allCurrentPanelChats.length} uncommitted new panelChats.`, LogLevel.INFO);\n            } else {\n                log(\"No uncommitted new panelChats found.\", LogLevel.INFO);\n            }\n        }\n    } catch (error) {\n        log(`Warning: Failed to process uncommitted changes: ${(error as Error).message}`, LogLevel.WARN);\n    }\n    \n\n    return {\n        commits: allCommits,\n        added: allAddedPanelChats.length > 0 ? added : null,\n        uncommitted\n    };\n}\n\n/**\n * Maps message IDs to their respective commit information.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to a Map where keys are message IDs and values are CommitData.\n */\nexport async function getIdToCommitInfo(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<Map<string, CommitData>> {\n    const gitHistory = await getGitHistory(context, repoPath, filePath);\n    const idToCommitInfo = new Map<string, CommitData>();\n\n    for (const commit of gitHistory.commits) {\n        for (const panelChat of commit.panelChats) {\n            for (const message of panelChat.messages) {\n                idToCommitInfo.set(message.id, commit);\n            }\n        }\n    }\n\n    return idToCommitInfo;\n}\n\n/**\n * Maps inline chat IDs to their respective commit information.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to a Map where keys are inline chat IDs and values are CommitData.\n */\nexport async function getInlineChatIdToCommitInfo(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<Map<string, CommitData>> {\n    const gitHistory = await getGitHistory(context, repoPath, filePath);\n    const idToCommitInfo = new Map<string, CommitData>();\n\n    for (const commit of gitHistory.commits) {\n        for (const inlineChat of commit.inlineChats) {\n            idToCommitInfo.set(inlineChat.inline_chat_id, commit);\n        }\n    }\n\n    return idToCommitInfo;\n}\n",
          "diffs": [
            {
              "count": 530,
              "added": false,
              "removed": false,
              "value": "import * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport { StashedState, PanelChat, isStashedState, isPanelChat } from './types';\nimport { InlineChatInfo } from './inline';\nimport { readStashedState } from './stashedState'; // Ensure this does not use gzip\nimport { execFile } from 'child_process';\nimport { promisify } from 'util';\n\nconst SCHEMA_VERSION = '1.0';\n\nexport type CommitData = {\n    commitHash: string;\n    date: Date;\n    commitMessage: string;\n    author: string;\n    panelChats: PanelChat[];\n    inlineChats: InlineChatInfo[];\n};\n\nexport type UncommittedData = {\n    panelChats: PanelChat[];\n    inlineChats: InlineChatInfo[];\n};\n\nexport type GitHistoryData = {\n    commits: CommitData[];\n    added: UncommittedData | null;\n    uncommitted: UncommittedData | null;\n};\n\nenum LogLevel {\n    INFO,\n    WARN,\n    ERROR\n}\n\nconst CURRENT_LOG_LEVEL = LogLevel.INFO;\n\n/**\n * Logs messages based on the specified log level.\n * @param message - The message to log.\n * @param level - The severity level of the log.\n */\nfunction log(message: string, level: LogLevel = LogLevel.INFO) {\n    if (level >= CURRENT_LOG_LEVEL) {\n        switch (level) {\n            case LogLevel.INFO:\n                console.log(message);\n            case LogLevel.WARN:\n                console.warn(message);\n                break;\n            case LogLevel.ERROR:\n                console.error(message);\n                break;\n        }\n    }\n}\n\nconst execFileAsync = promisify(execFile);\n\n/**\n * Executes a Git command and returns the output as a string.\n * @param args - Array of Git command arguments.\n * @param repoPath - The path to the Git repository.\n * @returns A Promise resolving to a string containing the command output.\n */\nasync function gitShowString(args: string[], repoPath: string): Promise<string> {\n    try {\n        const { stdout } = await execFileAsync('git', args, { cwd: repoPath });\n        return stdout;\n    } catch (error) {\n        throw new Error(`Git command failed: ${(error as Error).message}`);\n    }\n}\n\n\n/**\n * Processes a single commit's state.json and extracts active PanelChats and Messages.\n * @param parsedContent - The parsed StashedState from the commit.\n * @param currentMessageIds - Set of active message IDs.\n * @param currentInlineChatIds - Set of active inline chat IDs.\n * @param seenMessageIds - Set to track already processed message IDs.\n * @param commitData - The CommitData object to populate.\n * @param commitHash - The hash of the current commit (for logging purposes).\n */\nfunction processCommit(\n    parsedContent: StashedState,\n    currentMessageIds: Set<string>,\n    currentInlineChatIds: Set<string>,\n    seenMessageIds: Set<string>,\n    commitData: CommitData,\n    commitHash: string\n) {\n    log(`Processing Commit Hash: ${commitHash}`, LogLevel.INFO);\n\n    const { deletedChats } = parsedContent;\n    const deletedPanelChatIds = new Set(deletedChats.deletedPanelChatIDs);\n    const deletedMessageIds = new Set(deletedChats.deletedMessageIDs);\n\n    // Process Inline Chats\n    if (Array.isArray(parsedContent.inlineChats)) {\n        for (const inlineChat of parsedContent.inlineChats) {\n            const inlineChatId = inlineChat.inline_chat_id;\n            if (currentInlineChatIds.has(inlineChatId)) {\n                commitData.inlineChats.push(inlineChat);\n            }\n        }\n    }\n\n    // Process Panel Chats\n    for (const panelChat of parsedContent.panelChats) {\n        const panelChatId = panelChat.id;\n\n        // Skip deleted PanelChats\n        if (deletedPanelChatIds.has(panelChatId)) {\n            log(`PanelChat ID ${panelChatId} has been deleted in commit ${commitHash}. Excluding from processing.`, LogLevel.INFO);\n            continue;\n        }\n\n        // Retrieve or initialize existing PanelChat in commitData\n        let existingPanelChat = commitData.panelChats.find(pc => pc.id === panelChatId);\n        if (!existingPanelChat) {\n            existingPanelChat = { ...panelChat, messages: [], kv_store: {} };\n            commitData.panelChats.push(existingPanelChat);\n            log(`Initialized PanelChat ID ${panelChatId} in commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process Messages within PanelChat\n        for (const message of panelChat.messages) {\n            const messageId = message.id;\n\n            if (currentMessageIds.has(messageId) && !seenMessageIds.has(messageId) && !deletedMessageIds.has(messageId)) {\n                existingPanelChat.messages.push(message);\n                log(`Added Message ID ${messageId} from PanelChat ${panelChatId} in commit ${commitHash}.`, LogLevel.INFO);\n                seenMessageIds.add(messageId);\n            } else {\n                if (!currentMessageIds.has(messageId)) {\n                    log(`Message ID ${messageId} has been deleted in the current state. Excluding from commit ${commitHash}.`, LogLevel.INFO);\n                } else {\n                    log(`Message ID ${messageId} has already been processed. Skipping.`, LogLevel.INFO);\n                }\n            }\n        }\n    }\n}\n\n\n\n/**\n * Aggregates active PanelChat and InlineChat IDs from the current stashed state.\n * @param parsedCurrent - The current StashedState.\n * @returns An object containing sets of active PanelChat and Message IDs, and active InlineChat IDs.\n */\nfunction aggregateCurrentIds(parsedCurrent: StashedState) {\n    const currentMessageIds: Set<string> = new Set();\n    const currentPanelChatIds: Set<string> = new Set();\n    const currentInlineChatIds: Set<string> = new Set();\n\n    const { deletedChats, panelChats, inlineChats } = parsedCurrent;\n    const deletedPanelChatIds = new Set(deletedChats.deletedPanelChatIDs);\n    const deletedMessageIds = new Set(deletedChats.deletedMessageIDs);\n\n    for (const panelChat of panelChats) {\n        if (!deletedPanelChatIds.has(panelChat.id)) {\n            currentPanelChatIds.add(panelChat.id);\n            for (const message of panelChat.messages) {\n                if (!deletedMessageIds.has(message.id)) {\n                    currentMessageIds.add(message.id);\n                }\n            }\n        }\n    }\n\n    for (const inlineChat of inlineChats) {\n        currentInlineChatIds.add(inlineChat.inline_chat_id);\n    }\n\n    log(`Collected ${currentPanelChatIds.size} active PanelChat IDs, ${currentMessageIds.size} active Message IDs, and ${currentInlineChatIds.size} active InlineChat IDs.`, LogLevel.INFO);\n\n    return { currentMessageIds, currentPanelChatIds, currentInlineChatIds };\n}\n\n/**\n * Retrieves the Git history for a specific file, capturing PanelChats instead of flat messages.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to GitHistoryData containing commit history and uncommitted changes.\n */\nexport async function getGitHistory(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<GitHistoryData> {\n    const git: SimpleGit = simpleGit(repoPath);\n    log(\"Starting getGitHistory\", LogLevel.INFO);\n\n    // Ensure the file exists in the repository\n    const absoluteFilePath = path.resolve(repoPath, filePath);\n    if (!fs.existsSync(absoluteFilePath)) {\n        throw new Error(`File not found: ${absoluteFilePath}`);\n    }\n\n    // Step 1: Read and validate the current state.json\n    const parsedCurrent = readStashedState(context); \n    const { currentMessageIds, currentPanelChatIds, currentInlineChatIds } = aggregateCurrentIds(parsedCurrent);\n    const seenMessageIds: Set<string> = new Set();\n\n    // Step 2: Get the commit history for the file with --follow to track renames\n    const logArgs = ['log', '--reverse', '--follow', '--pretty=format:%H%x09%an%x09%ad%x09%s', '--', filePath];\n    let logData: string;\n\n    try {\n        logData = await git.raw(logArgs);\n        log(`Retrieved git log data successfully.`, LogLevel.INFO);\n    } catch (error) {\n        throw new Error(`Failed to retrieve git log: ${(error as Error).message}`);\n    }\n\n    const logLines = logData.split('\\n').filter(line => line.trim() !== '');\n    log(`Processing ${logLines.length} commits from git log.`, LogLevel.INFO);\n\n    const allCommitsMap: Map<string, CommitData> = new Map();\n\n    for (const line of logLines) {\n        const [commitHash, authorName, dateStr, ...commitMsgParts] = line.split('\\t');\n        const commitMessage = commitMsgParts.join('\\t');\n\n        // Get the file content at this commit using child_process\n        let fileContent: string;\n        try {\n            fileContent = await gitShowString(['show', `${commitHash}:${filePath}`], repoPath);\n            log(`Retrieved file content for commit ${commitHash}.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Could not retrieve file ${filePath} at commit ${commitHash}. Error: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Parse JSON\n        let parsedContent: StashedState;\n        try {\n            parsedContent = JSON.parse(fileContent);\n            if (!isStashedState(parsedContent)) {\n                throw new Error('Parsed content does not match StashedState structure.');\n            }\n            log(`Parsed state.json for commit ${commitHash} successfully.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Failed to parse JSON for commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            log(`Content: ${fileContent}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Initialize or retrieve existing CommitData for this commit\n        let commitData = allCommitsMap.get(commitHash);\n        if (!commitData) {\n            commitData = {\n                commitHash,\n                date: new Date(dateStr),\n                commitMessage,\n                author: authorName,\n                panelChats: [],\n                inlineChats: [],\n            };\n            allCommitsMap.set(commitHash, commitData);\n            log(`Initialized CommitData for commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process the commit's panelChats and inlineChats\n        processCommit(parsedContent, currentMessageIds, currentInlineChatIds, seenMessageIds, commitData, commitHash);\n    }\n\n    // Convert the map to an array and filter out empty commits\n    let allCommits: CommitData[] = Array.from(allCommitsMap.values())\n        .map(commit => ({\n            ...commit,\n            panelChats: commit.panelChats.filter(pc => pc.messages.length > 0)\n        }))\n        .filter(commit => commit.panelChats.length > 0);\n\n    log(`Filtered commits to exclude empty ones. Remaining commits count: ${allCommits.length}`, LogLevel.INFO);\n\n    // Step 3: Aggregate uncommitted added content\n    const allAddedPanelChats: PanelChat[] = parsedCurrent.panelChats\n        .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n        .map(pc => ({\n            ...pc,\n            messages: pc.messages.filter(msg => \n                !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                !seenMessageIds.has(msg.id)\n            )\n        }))\n        .filter(pc => pc.messages.length > 0);\n\n    const added: UncommittedData = {\n        panelChats: allAddedPanelChats,\n        inlineChats: parsedCurrent.inlineChats.filter(ic => currentInlineChatIds.has(ic.inline_chat_id))\n    };\n\n    // Step 4: Handle uncommitted changes\n    let uncommitted: UncommittedData | null = null;\n    try {\n        const currentUncommittedContent = context.workspaceState.get<PanelChat[]>('currentPanelChats') || [];\n\n        if (!Array.isArray(currentUncommittedContent) || !currentUncommittedContent.every(isPanelChat)) {\n            throw new Error('Parsed content does not match PanelChat structure.');\n        }\n\n        const allCurrentPanelChats: PanelChat[] = currentUncommittedContent\n            .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n            .map(pc => ({\n                ...pc,\n                messages: pc.messages.filter(msg => \n                    !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                    !seenMessageIds.has(msg.id)\n                )\n            }))\n            .filter(pc => pc.messages.length > 0);\n\n        if (allCurrentPanelChats.length > 0) {\n            uncommitted = {\n                panelChats: allCurrentPanelChats,\n                inlineChats: []\n            };\n            log(`Found ${allCurrentPanelChats.length} uncommitted new panelChats.`, LogLevel.INFO);\n        } else {\n            log(\"No uncommitted new panelChats found.\", LogLevel.INFO);\n        }\n    } catch (error) {\n        log(`Warning: Failed to read current uncommitted content: ${(error as Error).message}`, LogLevel.WARN);\n    }\n\n    return {\n        commits: allCommits,\n        added: allAddedPanelChats.length > 0 ? added : null,\n        uncommitted\n    };\n}\n\n/**\n * Retrieves the Git history for a specific file that also touches a target file.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the main target file within the repository.\n * @param targetFilePath - The relative path to the additional target file within the repository.\n * @returns A Promise resolving to GitHistoryData containing commit history and uncommitted changes.\n */\nexport async function getGitHistoryThatTouchesFile(\n    context: vscode.ExtensionContext,\n    repoPath: string,\n    filePath: string,\n    targetFilePath: string\n): Promise<GitHistoryData> {\n    const git: SimpleGit = simpleGit(repoPath);\n    log(\"Starting getGitHistoryThatTouchesFile\", LogLevel.INFO);\n\n    // Ensure both files exist in the repository\n    const absoluteFilePath = path.resolve(repoPath, filePath);\n    const absoluteTargetFilePath = path.resolve(repoPath, targetFilePath);\n    if (!fs.existsSync(absoluteFilePath)) {\n        throw new Error(`File not found: ${absoluteFilePath}`);\n    }\n    if (!fs.existsSync(absoluteTargetFilePath)) {\n        throw new Error(`Target file not found: ${absoluteTargetFilePath}`);\n    }\n\n    // Step 1: Read and validate the current state.json\n    const parsedCurrent = readStashedState(context); \n    const { currentMessageIds, currentPanelChatIds, currentInlineChatIds } = aggregateCurrentIds(parsedCurrent);\n    const seenMessageIds: Set<string> = new Set();\n\n    // Step 2: Get the commit history for the main file with --follow to track renames\n    const logArgs = ['log', '--reverse', '--follow', '--pretty=format:%H%x09%an%x09%ad%x09%s', '--', filePath];\n    let logData: string;\n\n    try {\n        logData = await git.raw(logArgs);\n        log(`Retrieved git log data successfully.`, LogLevel.INFO);\n    } catch (error) {\n        throw new Error(`Failed to retrieve git log for ${filePath}: ${(error as Error).message}`);\n    }\n\n    const logLines = logData.split('\\n').filter(line => line.trim() !== '');\n    log(`Processing ${logLines.length} commits from git log.`, LogLevel.INFO);\n\n    const allCommitsMap: Map<string, CommitData> = new Map();\n\n    for (const line of logLines) {\n        const [commitHash, authorName, dateStr, ...commitMsgParts] = line.split('\\t');\n        const commitMessage = commitMsgParts.join('\\t');\n\n        // Skip commits that are solely for deletions\n        if (\n            commitMessage.startsWith('Delete message with ID') || \n            commitMessage.startsWith('Delete PanelChat with ID')\n        ) {\n            log(`Skipping deletion commit ${commitHash}: ${commitMessage}`, LogLevel.INFO);\n            continue;\n        }\n\n        // Check if this commit modifies the targetFilePath\n        let modifiesTargetFile = false;\n        try {\n            const filesChanged = await git.raw(['diff-tree', '--no-commit-id', '--name-only', '-r', commitHash]);\n            const files = filesChanged.split('\\n').map(f => f.trim());\n            modifiesTargetFile = files.includes(targetFilePath);\n            log(\n                `Commit ${commitHash} ${modifiesTargetFile ? 'modifies' : 'does not modify'} target file ${targetFilePath}.`,\n                LogLevel.INFO\n            );\n        } catch (error) {\n            log(`Warning: Failed to retrieve files changed in commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        if (!modifiesTargetFile) {\n            continue;\n        }\n\n        // Get the file content at this commit\n        let fileContent: string;\n        try {\n            fileContent = await gitShowString(['show', `${commitHash}:${filePath}`], repoPath);\n            log(`Retrieved file content for commit ${commitHash}.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Could not retrieve file ${filePath} at commit ${commitHash}. Error: ${(error as Error).message}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Parse JSON\n        let parsedContent: StashedState;\n        try {\n            parsedContent = JSON.parse(fileContent);\n            if (!isStashedState(parsedContent)) {\n                throw new Error('Parsed content does not match StashedState structure.');\n            }\n            log(`Parsed state.json for commit ${commitHash} successfully.`, LogLevel.INFO);\n        } catch (error) {\n            log(`Warning: Failed to parse JSON for commit ${commitHash}: ${(error as Error).message}`, LogLevel.WARN);\n            log(`Content: ${fileContent}`, LogLevel.WARN);\n            continue; // Skip this commit\n        }\n\n        // Initialize or retrieve existing CommitData for this commit\n        let commitData = allCommitsMap.get(commitHash);\n        if (!commitData) {\n            commitData = {\n                commitHash,\n                date: new Date(dateStr),\n                commitMessage,\n                author: authorName,\n                panelChats: [],\n                inlineChats: [],\n            };\n            allCommitsMap.set(commitHash, commitData);\n            log(`Initialized CommitData for commit ${commitHash}.`, LogLevel.INFO);\n        }\n\n        // Process the commit's panelChats and inlineChats\n        processCommit(parsedContent, currentMessageIds, currentInlineChatIds, seenMessageIds, commitData, commitHash);\n    }\n\n    // Convert the map to an array and filter out empty commits\n    let allCommits: CommitData[] = Array.from(allCommitsMap.values())\n        .map(commit => ({\n            ...commit,\n            panelChats: commit.panelChats.filter(pc => pc.messages.length > 0)\n        }))\n        .filter(commit => commit.panelChats.length > 0);\n\n    log(`Filtered commits to exclude empty ones. Remaining commits count: ${allCommits.length}`, LogLevel.INFO);\n\n    // Step 3: Aggregate uncommitted added content\n    const allAddedPanelChats: PanelChat[] = parsedCurrent.panelChats\n        .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n        .map(pc => ({\n            ...pc,\n            messages: pc.messages.filter(msg => \n                !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                !seenMessageIds.has(msg.id)\n            )\n        }))\n        .filter(pc => pc.messages.length > 0);\n\n    const added: UncommittedData = {\n        panelChats: allAddedPanelChats,\n        inlineChats: parsedCurrent.inlineChats.filter(ic => currentInlineChatIds.has(ic.inline_chat_id))\n    };\n\n    // Step 4: Check for uncommitted changes\n    let uncommitted: UncommittedData | null = null;\n    try {\n        const status = await git.status();\n        const isModified = [\n            status.modified,\n            status.not_added,\n            status.created\n        ].some(list => list.includes(targetFilePath));\n\n        if (isModified) {\n            log(`File ${targetFilePath} is modified. Processing uncommitted changes.`, LogLevel.INFO);\n\n            const currentUncommittedContent = context.workspaceState.get<PanelChat[]>('currentPanelChats') || [];\n\n            if (!Array.isArray(currentUncommittedContent) || !currentUncommittedContent.every(isPanelChat)) {\n                throw new Error('Parsed content does not match PanelChat structure.');\n            }\n\n            const allCurrentPanelChats: PanelChat[] = currentUncommittedContent\n                .filter(pc => !parsedCurrent.deletedChats.deletedPanelChatIDs.includes(pc.id))\n                .map(pc => ({\n                    ...pc,\n                    messages: pc.messages.filter(msg => \n                        !parsedCurrent.deletedChats.deletedMessageIDs.includes(msg.id) && \n                        !seenMessageIds.has(msg.id)\n                    )\n                }))\n                .filter(pc => pc.messages.length > 0);\n\n            if (allCurrentPanelChats.length > 0) {\n                uncommitted = {\n                    panelChats: allCurrentPanelChats,\n                    inlineChats: []\n                };\n                log(`Found ${allCurrentPanelChats.length} uncommitted new panelChats.`, LogLevel.INFO);\n            } else {\n                log(\"No uncommitted new panelChats found.\", LogLevel.INFO);\n            }\n        }\n    } catch (error) {\n        log(`Warning: Failed to process uncommitted changes: ${(error as Error).message}`, LogLevel.WARN);\n    }\n"
            },
            {
              "count": 1,
              "added": true,
              "removed": false,
              "value": "    \n"
            },
            {
              "count": 49,
              "added": false,
              "removed": false,
              "value": "\n    return {\n        commits: allCommits,\n        added: allAddedPanelChats.length > 0 ? added : null,\n        uncommitted\n    };\n}\n\n/**\n * Maps message IDs to their respective commit information.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to a Map where keys are message IDs and values are CommitData.\n */\nexport async function getIdToCommitInfo(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<Map<string, CommitData>> {\n    const gitHistory = await getGitHistory(context, repoPath, filePath);\n    const idToCommitInfo = new Map<string, CommitData>();\n\n    for (const commit of gitHistory.commits) {\n        for (const panelChat of commit.panelChats) {\n            for (const message of panelChat.messages) {\n                idToCommitInfo.set(message.id, commit);\n            }\n        }\n    }\n\n    return idToCommitInfo;\n}\n\n/**\n * Maps inline chat IDs to their respective commit information.\n * @param context - The VSCode extension context.\n * @param repoPath - The path to the Git repository.\n * @param filePath - The relative path to the target file within the repository.\n * @returns A Promise resolving to a Map where keys are inline chat IDs and values are CommitData.\n */\nexport async function getInlineChatIdToCommitInfo(context: vscode.ExtensionContext, repoPath: string, filePath: string): Promise<Map<string, CommitData>> {\n    const gitHistory = await getGitHistory(context, repoPath, filePath);\n    const idToCommitInfo = new Map<string, CommitData>();\n\n    for (const commit of gitHistory.commits) {\n        for (const inlineChat of commit.inlineChats) {\n            idToCommitInfo.set(inlineChat.inline_chat_id, commit);\n        }\n    }\n\n    return idToCommitInfo;\n}\n"
            }
          ]
        }
      ],
      "selection": null,
      "timestamp": "2024-10-03T02:56:35.934Z",
      "prompt": "expression for total number of panel chats stored in allCommits",
      "parent_inline_chat_id": null
    },
    {
      "inline_chat_id": "ab33775d-e104-46db-a1ed-4f92102ded4a",
      "file_diff": [
        {
          "file_path": "src/panelview.ts",
          "before_content": "import * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport { CommitData, GitHistoryData, getGitHistory, getGitHistoryThatTouchesFile } from './panelgit';\nimport { PanelChat } from './types';\nimport { readStashedState, writeStashedState, removeMessageFromStashedState, removePanelChatFromStashedState, writeChatToStashedState } from './stashedState';\nimport { panelChatsToMarkdown } from './markdown'; // Added import\nimport { STASHED_GAIT_STATE_FILE_NAME } from './constants';\nimport posthog from 'posthog-js';\nimport { identifyUser } from './identify_user';\n\nexport class PanelViewProvider implements vscode.WebviewViewProvider {\n    public static readonly viewType = 'gait-copilot.panelView';\n\n    private _view?: vscode.WebviewView;\n    private _commits: CommitData[] = [];\n    private _isFilteredView: boolean = false; // New state to track view type\n\n    /**\n     * Loads commits and integrates uncommitted changes into the commits array.\n     * Supports both default and filtered views based on _isFilteredView.\n     */\n    private async loadCommitsAndChats(additionalFilePath?: string) {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n            //vscode.window.showErrorMessage('No workspace folder found.');\n            return;\n        }\n        let context = this._context;\n\n        const repoPath = workspaceFolder.uri.fsPath;\n        const filePath = `.gait/${STASHED_GAIT_STATE_FILE_NAME}`; // Replace with your actual file path relative to repo\n\n        try {\n            if (this._isFilteredView && additionalFilePath) {\n                const gitHistory: GitHistoryData = await getGitHistoryThatTouchesFile(this._context, repoPath, filePath, additionalFilePath);\n\n                // Map CommitData from getGitHistoryThatTouchesFile to the class's commit structure\n                this._commits = gitHistory.commits.map(commit => ({\n                    commitHash: commit.commitHash,\n                    commitMessage: commit.commitMessage,\n                    author: commit.author,\n                    date: new Date(commit.date),\n                    panelChats: commit.panelChats,\n                    inlineChats: commit.inlineChats\n                })).sort((a, b) => b.date.getTime() - a.date.getTime());\n\n                if (gitHistory.added) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'added',\n                        author: 'You',\n                        commitMessage: 'Added Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.added.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.added.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n                else{\n                    console.log(\"No added changes\");\n                }\n\n                // Handle uncommitted changes by appending them to the commits array\n                if (gitHistory.uncommitted) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'uncommitted',\n                        author: 'You',\n                        commitMessage: 'Unadded Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.uncommitted.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.uncommitted.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n            } else {\n                const gitHistory: GitHistoryData = await getGitHistory(this._context, repoPath, filePath);\n\n                // Map CommitData from getGitHistory to the class's commit structure\n                this._commits = gitHistory.commits.map(commit => ({\n                    commitHash: commit.commitHash,\n                    commitMessage: commit.commitMessage,\n                    author: commit.author,\n                    date: new Date(commit.date),\n                    panelChats: commit.panelChats,\n                    inlineChats: commit.inlineChats\n                })).sort((a, b) => b.date.getTime() - a.date.getTime());\n\n                if (gitHistory.added) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'added',\n                        author: 'You',\n                        commitMessage: 'Added Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.added.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.added.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n\n                // Handle uncommitted changes by appending them to the commits array\n                if (gitHistory.uncommitted) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'uncommitted',\n                        author: 'You',\n                        commitMessage: 'Unadded Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.uncommitted.panelChats,\n                        inlineChats: gitHistory.uncommitted.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n            }\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Error loading git history: ${error.message}`);\n            this._commits = [];\n        }\n    }\n\n    /**\n     * Updates the webview content by loading commits and integrating uncommitted changes.\n     */\n    public async updateContent() {\n\n        if (this._isFilteredView) {\n            const editor = vscode.window.activeTextEditor;\n            if (editor) {\n                const document = editor.document;\n                const filePath = vscode.workspace.asRelativePath(document.uri.fsPath);\n                await this.loadCommitsAndChats(filePath);\n            }\n        } else {\n            await this.loadCommitsAndChats();\n        }\n        if (this._view) {\n            this._view.webview.postMessage({\n                type: 'update',\n                commits: this._commits,\n            });\n        }\n    }\n\n    constructor(private readonly _context: vscode.ExtensionContext) {\n        // Initialize by loading commits and chats\n        this.loadCommitsAndChats().catch(error => {\n            vscode.window.showErrorMessage(`Initialization error: ${(error as Error).message}`);\n        });\n    }\n\n    private async handleDeletePanelChat(panelChatId: string) {\n        const stashedState = readStashedState(this._context);\n        stashedState.deletedChats.deletedPanelChatIDs.push(panelChatId);\n        writeStashedState(this._context, stashedState);\n    }\n\n    private async handleRemovePanelChatFromStashedState(panelChatId: string) {\n        console.log(`Removing panelChat with ID ${panelChatId} from stashed state.`);\n        removePanelChatFromStashedState(this._context, panelChatId);\n    }\n\n    private async handleRemoveMessageFromStashedState(messageId: string) {\n        console.log(`Removing message with ID ${messageId} from stashed state.`);\n        removeMessageFromStashedState(this._context, messageId);\n    }\n\n    private async handleWriteChatToStashedState(panelChatId?: string, messageId?: string) {\n        if ((panelChatId && messageId) || (!panelChatId && !messageId)) {\n            vscode.window.showErrorMessage('Invalid parameters: Provide either panelChatId or messageId, but not both.');\n            if (panelChatId && messageId) {\n                vscode.window.showErrorMessage('Both panelChatId and messageId provided. Please provide only one.');\n            }\n            else {\n                vscode.window.showErrorMessage('No panelChatId or messageId provided. Please provide one.');\n            }\n            return;\n        }\n\n        try {\n            if (panelChatId) {\n                // Find the PanelChat with the given panelChatId\n                    const panelChat = this._commits[0].panelChats.find(pc => pc.id === panelChatId);\n                    if (panelChat) {\n                        // Write the entire PanelChat to stashed state\n                        await writeChatToStashedState(this._context, panelChat);\n                        vscode.window.showInformationMessage(`PanelChat with ID ${panelChatId} has been stashed.`);\n                        return;\n                    }\n                \n                vscode.window.showErrorMessage(`PanelChat with ID ${panelChatId} not found.`);\n            } else if (messageId) {\n                // Find the MessageEntry with the given messageId\n                    for (const panelChat of this._commits[0].panelChats) {\n                        const message = panelChat.messages.find(msg => msg.id === messageId);\n                        if (message) {\n                            // Construct a new PanelChat containing only this message\n                            const newPanelChat: PanelChat = {\n                                ai_editor: panelChat.ai_editor,\n                                id: panelChat.id,\n                                customTitle: `Stashed Message ${message.id}`,\n                                parent_id: null,\n                                created_on: new Date().toISOString(),\n                                messages: [message],\n                                kv_store: {}\n                            };\n                            // Write the new PanelChat to stashed state\n                            await writeChatToStashedState(this._context, newPanelChat);\n                            vscode.window.showInformationMessage(`Message with ID ${messageId} has been stashed.`);\n                            return;\n                        }\n                    \n                }\n                vscode.window.showErrorMessage(`Message with ID ${messageId} not found.`);\n            }\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to write chat to stashed state: ${error.message}`);\n            console.error(`Error in handleWriteChatToStashedState: ${error.stack}`);\n        }\n    }\n\n    public resolveWebviewView(\n        webviewView: vscode.WebviewView,\n        context: vscode.WebviewViewResolveContext,\n        _token: vscode.CancellationToken\n    ) {\n        identifyUser(this._context);\n        posthog.capture('$pageview');\n        this._view = webviewView;\n\n        webviewView.webview.options = {\n            enableScripts: true,\n        };\n\n        webviewView.webview.html = this.getHtmlForWebview(webviewView.webview);\n\n        webviewView.webview.onDidReceiveMessage(message => {\n            switch (message.command) {\n                case 'webviewReady':\n                    this.updateContent();\n                    break;\n                case 'deleteMessage':\n                    posthog.capture('delete_message');\n                    this.handleDeleteMessage(message.id);\n                    this.updateContent();\n                    break;\n                case 'deletePanelChat':\n                    posthog.capture('delete_panelchat');\n                    this.handleDeletePanelChat(message.id);\n                    this.updateContent();\n                    break;\n                case 'refresh':\n                    this.updateContent();\n                    break;\n                case 'switchView':\n                    this.handleSwitchView(message.view);\n                    break;\n                case 'appendContext': // New case for appending context\n                    this.handleAppendContext(message.commitHash, message.panelChatId);\n                    break;\n                case 'writeChatToStashedState': // New case for writing chat to stashed state\n                    this.handleWriteChatToStashedState(message.panelChatId, message.messageId);\n                    posthog.capture('manual_stage');\n                    this.updateContent();\n                    break;                \n                case 'removePanelChatFromStashedState': // New case for removing panelChat from stashed state\n                    this.handleRemovePanelChatFromStashedState(message.panelChatId);\n                    posthog.capture('manual_unstage');\n                    this.updateContent();\n                    break;\n                case 'removeMessageFromStashedState': // New case for removing message from stashed state\n                    this.handleRemoveMessageFromStashedState(message.messageId);\n                    this.updateContent();\n                    break;\n                case 'openFile':\n                    this.handleOpenFile(message.path);\n                    break;\n                default:\n                    break;\n            }\n        });\n\n        webviewView.onDidChangeVisibility(() => {\n            if (webviewView.visible) {\n                this.updateContent();\n            }\n        });\n    }\n\n    /**\n     * Handles switching between default and filtered views based on user selection.\n     * @param view - The selected view type.\n     */\n    private async handleSwitchView(view: string) {\n        if (view === 'filtered') {\n            this._isFilteredView = true;\n            //await this.updateContent();\n        } else {\n            // Default view\n            this._isFilteredView = false;\n        }\n        await this.updateContent();\n    }\n\n    /**\n     * Handles the deletion of a message by its ID.\n     * @param messageId - The ID of the message to delete.\n     */\n    private async handleDeleteMessage(messageId: string) {\n        const stashedState = readStashedState(this._context);\n        stashedState.deletedChats.deletedMessageIDs.push(messageId);\n        writeStashedState(this._context, stashedState);\n    }\n\n    /**\n     * Handles appending panelChat messages to gaitContext.md\n     * @param commitHash - The hash of the commit containing the panelChat.\n     * @param panelChatId - The ID of the panelChat to append.\n     */\n    private async handleAppendContext(commitHash: string, panelChatId: string) {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n            //vscode.window.showErrorMessage('No workspace folder found.');\n            return;\n        }\n\n        const repoPath = workspaceFolder.uri.fsPath;\n        const filePath = path.join(repoPath, 'gait_context.md');\n\n        try {\n            // Ensure the file exists; if not, create it with a header\n            if (!fs.existsSync(filePath)) {\n                fs.writeFileSync(filePath, '# Gait Context\\n\\n', 'utf-8');\n            }\n\n            // Find the specific commit\n            const targetCommit = this._commits.find(commit => commit.commitHash === commitHash);\n            if (!targetCommit) {\n                vscode.window.showErrorMessage(`Commit with hash ${commitHash} not found.`);\n                return;\n            }\n\n            // Find the specific panelChat within the commit\n            const targetPanelChat = targetCommit.panelChats.find(pc => pc.id === panelChatId);\n            if (!targetPanelChat) {\n                vscode.window.showErrorMessage(`PanelChat with ID ${panelChatId} not found in commit ${commitHash}.`);\n                return;\n            }\n\n            // Convert the panelChat to Markdown\n            const markdownContent = panelChatsToMarkdown([{ commit: targetCommit, panelChat: targetPanelChat }]);\n\n            // Append the markdown content to gaitContext.md\n            fs.appendFileSync(filePath, markdownContent + '\\n\\n', 'utf-8');\n            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(filePath), { viewColumn: vscode.ViewColumn.Beside });\n            await vscode.commands.executeCommand('aichat.newchataction');\n\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to append context: ${error.message}`);\n            console.error(`Error appending context: ${error.stack}`);\n        }\n    }\n\n    /**\n     * Handles opening a file in the editor.\n     * @param filePath - The path of the file to open.\n     */\n    private async handleOpenFile(filePath: string) {\n        console.log(`Opening file: ${filePath}`);\n        try {\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n            if (!workspaceFolder) {\n                vscode.window.showErrorMessage('No workspace folder found.');\n                return;\n            }\n\n            const fullPath = vscode.Uri.file(path.join(workspaceFolder.uri.fsPath, filePath));\n            const document = await vscode.workspace.openTextDocument(fullPath);\n            await vscode.window.showTextDocument(document);\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to open file: ${error.message}`);\n        }\n    }\n\n    /**\n     * Generates the HTML content for the webview, including a dropdown for view selection.\n     * @param webview - The Webview instance.\n     * @returns A string containing the HTML.\n     */\n    private getHtmlForWebview(webview: vscode.Webview): string {\n        const nonce = getNonce();\n        const prismCssPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'prism.css');\n        const prismJsPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'prism.js');\n        const markedJsPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'marked.js'); // Path to Marked.js\n        const prismCssUri = webview.asWebviewUri(prismCssPath);\n        const prismJsUri = webview.asWebviewUri(prismJsPath);\n        const markedJsUri = webview.asWebviewUri(markedJsPath); // URI for Marked.js\n        const workspaceFolderPath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\n\n        return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <script>\n    !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(\".\");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement(\"script\")).type=\"text/javascript\",p.async=!0,p.src=s.api_host.replace(\".i.posthog.com\",\"-assets.i.posthog.com\")+\"/static/array.js\",(r=t.getElementsByTagName(\"script\")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a=\"posthog\",u.people=u.people||[],u.toString=function(t){var e=\"posthog\";return\"posthog\"!==a&&(e+=\".\"+a),t||(e+=\" (stub)\"),e},u.people.toString=function(){return u.toString(1)+\".people (stub)\"},o=\"capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys getNextSurveyStep onSessionId\".split(\" \"),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);\n    posthog.init('phc_vosMtvFFxCN470e8uHGDYCD6YuuSRSoFoZeLuciujry',{api_host:'https://us.i.posthog.com',})\n    </script>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Git Commit History</title>\n    \n <!-- Content Security Policy -->\n    <meta http-equiv=\"Content-Security-Policy\" content=\"\n        default-src 'none';\n        style-src 'nonce-${nonce}' ${webview.cspSource};\n        script-src 'nonce-${nonce}' ${webview.cspSource};\n        connect-src 'self';\n        img-src 'self';\n        font-src 'self';\n    \">\n    \n    <!-- Prism.js CSS -->\n    <link href=\"${prismCssUri}\" rel=\"stylesheet\" />\n    <!-- Marked.js -->\n    <script src=\"${markedJsUri}\" nonce=\"${nonce}\"></script>\n\n    <style nonce=\"${nonce}\">\n        body {\n            font-family: var(--vscode-font-family);\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n            padding: 0;\n            margin: 0;\n            overflow: auto;\n        }\n        .container {\n            max-width: 1000px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        .header {\n            background-color: var(--vscode-titleBar-activeBackground);\n            color: var(--vscode-titleBar-activeForeground);\n            padding: 15px;\n            border-radius: 5px 5px 0 0;\n            margin-bottom: 20px;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n        }\n        .header h2 {\n            margin: 0;\n            font-size: 1.5em;\n        }\n        .commit {\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            padding: 15px;\n            margin-bottom: 15px;\n            background-color: var(--vscode-editor-inactiveSelectionBackground);\n        }\n        .commit-date {\n            color: var(--vscode-descriptionForeground);\n            font-size: 0.9em;\n        }\n        .commit-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            cursor: pointer;\n        }\n        .commit-header:hover {\n            background-color: var(--vscode-editor-selectionBackground);\n        }\n        .commit-header h3 {\n            margin: 0;\n            font-size: 1.2em;\n        }\n        .commit-details {\n            display: none;\n            margin-top: 10px;\n        }\n        .panel-chat {\n            margin-bottom: 15px;\n            padding: 10px;\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            background-color: var(--vscode-editor-background);\n        }\n        .panel-chat-header {\n            font-weight: bold;\n            margin-bottom: 5px;\n            display: flex;\n            align-items: center;\n            cursor: pointer; /* Make it clickable */\n        }\n        .panel-chat-header:hover {\n            background-color: var(--vscode-editor-selectionBackground);\n        }\n        .panel-chat-info {\n            font-size: 0.9em;\n            color: var(--vscode-descriptionForeground);\n            margin-bottom: 10px;\n        }\n        .panel-chat-details {\n            display: none; /* Hidden by default */\n            margin-top: 10px;\n        }\n        .message-container {\n            margin-bottom: 15px;\n            position: relative;\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            padding: 10px;\n            background-color: var(--vscode-editor-background);\n        }\n        .delete-button {\n            position: absolute;\n            top: 10px;\n            right: 10px;\n            background: transparent;\n            border: none;\n            color: red;\n            font-weight: bold;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        .delete-panelchat-button {\n            background: transparent;\n            border: none;\n            color: red;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .delete-panelchat-button:hover {\n            color: darkred;\n        }\n        .append-context-button {\n            background: transparent;\n            border: none;\n            color: blue;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .append-context-button:hover {\n            color: darkblue;\n        }\n        .write-chat-button {\n            background: transparent;\n            border: none;\n            color: green;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .write-chat-button:hover {\n            color: darkgreen;\n        }\n        .remove-chat-button {\n            background: transparent;\n            border: none;\n            color: orange;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .remove-chat-button:hover {\n            color: darkorange;\n        }\n        .message, .response {\n            padding: 10px;\n            border-radius: 5px;\n            margin-bottom: 5px;\n        }\n        .message {\n            background-color: var(--vscode-editor-selectionBackground);\n            word-wrap: break-word;\n        }\n        .response {\n            background-color: var(--vscode-editorWidget-background);\n            word-wrap: break-word;\n        }\n        pre {\n            background-color: var(--vscode-textCodeBlock-background);\n            padding: 8px;\n            border-radius: 3px;\n            font-family: var(--vscode-editor-font-family);\n            overflow-x: auto;\n        }\n        code {\n            font-family: var(--vscode-editor-font-family);\n            font-size: 0.9em;\n        }\n        .no-commits, .no-messages {\n            text-align: center;\n            color: var(--vscode-editorError-foreground);\n            font-style: italic;\n            margin-top: 20px;\n        }\n\n        /* Dropdown Styles */\n        .dropdown-container {\n            margin-bottom: 20px;\n            display: flex;\n            justify-content: flex-end;\n            align-items: center;\n        }\n\n        .dropdown-container label {\n            margin-right: 10px;\n            font-weight: bold;\n        }\n\n        .dropdown-container select {\n            padding: 5px;\n            border-radius: 4px;\n            border: 1px solid var(--vscode-editorWidget-border);\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n        }\n\n        /* Modal Styles */\n        .modal {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            z-index: 1000; /* Ensure it's on top */\n        }\n\n        .modal-content {\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n            padding: 20px;\n            border-radius: 8px;\n            width: 300px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n\n        .modal-buttons {\n            display: flex;\n            justify-content: flex-end;\n            margin-top: 20px;\n        }\n\n        .modal-buttons button {\n            margin-left: 10px;\n            padding: 5px 10px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n\n        #confirmYes {\n            background-color: var(--vscode-button-background);\n            color: var(--vscode-button-foreground);\n        }\n\n        #confirmNo {\n            background-color: var(--vscode-button-secondaryBackground);\n            color: var(--vscode-button-secondaryForeground);\n        }\n\n        .hidden {\n            display: none;\n        }\n\n        .visible {\n            display: flex; /* or block, depending on your layout needs */\n        }\n\n\n        /* Override Prism.js styles if necessary */\n        /* Example: Adjusting code block background */\n        pre[class*=\"language-\"] {\n            background: var(--vscode-textCodeBlock-background) !important;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h2>Git Commit History</h2>\n            <button id=\"refreshButton\" title=\"Refresh Commit History\">🔄</button>\n        </div>\n\n        <!-- Dropdown for selecting view -->\n        <div class=\"dropdown-container\">\n            <label for=\"viewSelect\">View:</label>\n            <select id=\"viewSelect\">\n                <option value=\"default\">All Commits</option>\n                <option value=\"filtered\">Commits Touching Specific File</option>\n            </select>\n        </div>\n\n        <div id=\"content\">\n            <div class=\"no-commits\">Loading commit history...</div>\n        </div>\n    </div>\n\n    <!-- Confirmation Modal -->\n    <div id=\"confirmModal\" class=\"modal hidden\">\n        <div class=\"modal-content\">\n            <p>Are you sure you want to delete this item?</p>\n            <div class=\"modal-buttons\">\n                <button id=\"confirmYes\">Yes</button>\n                <button id=\"confirmNo\">No</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Prism.js JS -->\n    <script src=\"${prismJsUri}\" nonce=\"${nonce}\"> </script>\n\n    <script nonce=\"${nonce}\">\n\n        setInterval(() => {\n            vscode.postMessage({ command: 'refresh' });\n        }, 3000);\n\n        const vscode = acquireVsCodeApi();\n        const workspaceFolderPath = '${workspaceFolderPath}';\n\n        /**\n         * Escapes HTML characters to prevent XSS attacks.\n         * @param {string} text - The text to escape.\n         * @returns {string} - The escaped text.\n         */\n        function escapeHtml(text) {\n            const map = {\n                '&': '&amp;',\n                '<': '&lt;',\n                '>': '&gt;',\n                '\"': '&quot;',\n                \"'\": '&#039;'\n            };\n            return text.replace(/[&<>\"']/g, function(m) { return map[m]; });\n        }\n\n        function formatResponse(responseText) {\n            if (typeof responseText !== 'string') {\n                console.warn('formatResponse received non-string responseText:', responseText);\n                return '<em>Invalid response text.</em>';\n            }\n\n            // Enhanced regex to handle optional newline after language specifier\n            const codeBlockRegex = /\\`\\`\\`(\\\\w+)?\\\\n?([\\\\s\\\\S]+?)\\`\\`\\`/g;\n            let formattedText = '';\n            let lastIndex = 0;\n            let match;\n            let matchFound = false;\n\n            console.warn('Response text:', responseText); // Debugging log\n\n            while ((match = codeBlockRegex.exec(responseText)) !== null) {\n                matchFound = true;\n                const index = match.index;\n                console.warn('Matched code block:', match[0]); // Debugging log\n\n                // Escape and append text before the code block\n                formattedText += escapeHtml(responseText.slice(lastIndex, index));\n\n                const language = match[1] ? match[1].trim().replace(/\\\\n+$/, '') : '';\n                const code = match[2] ? escapeHtml(match[2].trim()) : '';\n\n                console.warn('Language', JSON.stringify(language));// Debugging log\n                console.warn('Code', JSON.stringify(code)); // Debugging log\n\n                // Append the formatted code block\n                formattedText += \\`<pre><code class=\"language-\\${language}\">\\${code}</code></pre>\\`;\n\n                lastIndex = index + match[0].length;\n            }\n\n            if (!matchFound) {\n                console.warn('No code blocks found in responseText.');\n            }\n\n            // Escape and append the remaining text after the last code block\n            formattedText += marked.parse(escapeHtml(responseText.slice(lastIndex)));\n            return formattedText;\n        }\n\n\n        /**\n         * Attaches click listeners to commit headers to toggle visibility of commit details.\n         */\n        function attachCommitToggleListeners() {\n            const commitHeaders = document.querySelectorAll('.commit-header');\n            commitHeaders.forEach(header => {\n                header.addEventListener('click', () => {\n                    const details = header.nextElementSibling;\n                    if (details) {\n                        if (details.style.display === 'block') {\n                            details.style.display = 'none';\n                        } else {\n                            details.style.display = 'block';\n                            const codeBlocks = details.querySelectorAll('pre code');\n                            console.log('Found code blocks:', codeBlocks);\n                            codeBlocks.forEach((block) => {\n                                Prism.highlightElement(block);\n                            });\n                        }\n                    }\n                });\n            });\n        }\n\n        /**\n         * Attaches click listeners to panel chat headers to toggle visibility of panel chat details.\n         */\n        function attachPanelChatToggleListeners() {\n            const panelChatHeaders = document.querySelectorAll('.panel-chat-header');\n            panelChatHeaders.forEach(header => {\n                header.addEventListener('click', () => {\n                    const details = header.nextElementSibling;\n                    if (details) {\n                        if (details.style.display === 'block') {\n                            details.style.display = 'none';\n                        } else {\n                            details.style.display = 'block';\n                            const codeBlocks = details.querySelectorAll('pre code');\n                            console.log('Found code blocks in panel chat:', codeBlocks);\n                            codeBlocks.forEach((block) => {\n                                Prism.highlightElement(block);\n                            });\n                        }\n                    }\n                });\n            });\n        }\n\n        function attachLinkListeners() {\n            const contentElement = document.getElementById('content');\n            contentElement.addEventListener('click', (event) => {\n                const target = event.target;\n                if (target && target.matches('a.context-link')) {\n                    event.preventDefault();\n                    const path = target.dataset.path;\n                    if (path) {\n                        console.log('Context link clicked:', path);\n                        vscode.postMessage({ command: 'openFile', path: path });\n                    } else {\n                        console.warn('Clicked link does not have a data-path attribute.');\n                    }\n                }\n            });\n        }\n\n        /**\n         * Attaches click listeners to delete, write, and remove buttons to handle respective actions.\n         */\n        function attachButtonListeners() {\n            // Existing Delete Message Buttons\n            const deleteMessageButtons = document.querySelectorAll('.delete-button');\n            deleteMessageButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const messageId = button.getAttribute('data-id');\n                    if (messageId) {\n                        showConfirmationModal('message', messageId);\n                    } else {\n                        console.warn('Delete button clicked without a valid message ID.');\n                    }\n                });\n            });\n\n            // Existing Delete PanelChat Buttons\n            const deletePanelChatButtons = document.querySelectorAll('.delete-panelchat-button');\n            deletePanelChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const panelChatId = button.getAttribute('data-id');\n                    if (panelChatId) {\n                        showConfirmationModal('panelChat', panelChatId);\n                    } else {\n                        console.warn('Delete PanelChat button clicked without a valid PanelChat ID.');\n                    }\n                });\n            });\n\n            // New Append to gaitContext.md Buttons\n            const appendContextButtons = document.querySelectorAll('.append-context-button');\n            appendContextButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const commitHash = button.getAttribute('data-commit');\n                    const panelChatId = button.getAttribute('data-id');\n                    if (commitHash && panelChatId) {\n                        vscode.postMessage({ \n                            command: 'appendContext', \n                            commitHash: commitHash, \n                            panelChatId: panelChatId \n                        });\n                    } else {\n                        console.warn('Append Context button clicked without valid commitHash or PanelChat ID.');\n                    }\n                });\n            });\n\n            // New Write Chat Buttons for Unadded Changes\n            const writeChatButtons = document.querySelectorAll('.write-chat-button');\n            writeChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    const panelChatId = button.getAttribute('data-panel-chat-id');\n                    const messageId = button.getAttribute('data-message-id');\n\n                    if (panelChatId) {\n                        vscode.postMessage({\n                            command: 'writeChatToStashedState',\n                            panelChatId: panelChatId\n                        });\n                    } else if (messageId) {\n                        vscode.postMessage({\n                            command: 'writeChatToStashedState',\n                            messageId: messageId\n                        });\n                    } else {\n                        console.warn('Write Chat button clicked without valid data.');\n                    }\n                });\n            });\n\n            // New Remove Chat Buttons for Added Changes\n            const removeChatButtons = document.querySelectorAll('.remove-chat-button');\n            removeChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    const panelChatId = button.getAttribute('data-panel-chat-id');\n                    const messageId = button.getAttribute('data-message-id');\n                    if (panelChatId) {\n                        vscode.postMessage({\n                            command: 'removePanelChatFromStashedState',\n                            panelChatId: panelChatId\n                        });\n                    } else if (messageId) {\n                        vscode.postMessage({\n                            command: 'removeMessageFromStashedState',\n                            messageId: messageId\n                        });\n                    } else {\n                        console.warn('Remove Chat button clicked without valid data.');\n                    }\n                });\n            });\n        }\n\n        /**\n         * Displays a custom confirmation modal before deleting a message or panel chat.\n         * @param {string} type - The type of deletion ('message' or 'panelChat').\n         * @param {string} id - The ID of the item to delete.\n         */\n        function showConfirmationModal(type, id) {\n            const modal = document.getElementById('confirmModal');\n            const modalMessage = modal.querySelector('p');\n            modalMessage.textContent = type === 'message' \n                ? 'Are you sure you want to delete this message?' \n                : 'Are you sure you want to delete this PanelChat?';\n\n            // Remove 'hidden' and add 'visible' to show the modal\n            modal.classList.remove('hidden');\n            modal.classList.add('visible');\n\n            // Handle \"Yes\" button click\n            document.getElementById('confirmYes').onclick = function() {\n                if (type === 'message') {\n                    //console.log('Sending deleteMessage command for ID: ' + id);\n                    vscode.postMessage({ command: 'deleteMessage', id: id });\n                } else if (type === 'panelChat') {\n                    //console.log('Sending deletePanelChat command for ID: ' + id);\n                    vscode.postMessage({ command: 'deletePanelChat', id: id });\n                }\n                // Hide the modal after action\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            };\n\n            // Handle \"No\" button click\n            document.getElementById('confirmNo').onclick = function() {\n                console.log('Deletion cancelled by user.');\n                // Hide the modal\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            };\n        }\n\n        // Close the modal when clicking outside of the modal content\n        window.onclick = function(event) {\n            const modal = document.getElementById('confirmModal');\n            if (event.target == modal) {\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            }\n        };\n\n\n        /**\n         * Attaches an event listener to the refresh button to update commit history.\n         */\n        document.getElementById('refreshButton').addEventListener('click', () => {\n            vscode.postMessage({ command: 'refresh' });\n        });\n\n        /**\n         * Attaches an event listener to the view dropdown to switch views.\n         */\n        document.getElementById('viewSelect').addEventListener('change', (event) => {\n            const select = event.target;\n            const selectedView = select.value;\n            vscode.postMessage({ command: 'switchView', view: selectedView });\n        });\n\n        let scrollPosition = 0;\n        let expandedCommits = new Set();\n        let expandedPanelChats = new Set(); // New Set to track expanded panel chats\n\n        function saveScrollPosition() {\n            scrollPosition = document.scrollingElement.scrollTop;\n        }\n\n        function restoreScrollPosition() {\n            document.scrollingElement.scrollTop = scrollPosition;\n        }\n\n        function saveExpandedCommits() {\n            expandedCommits.clear();\n            document.querySelectorAll('.commit-details').forEach((details, index) => {\n                if (details.style.display === 'block') {\n                    expandedCommits.add(index);\n                }\n            });\n        }\n\n        function restoreExpandedCommits() {\n            document.querySelectorAll('.commit-details').forEach((details, index) => {\n                if (expandedCommits.has(index)) {\n                    details.style.display = 'block';\n                }\n            });\n        }\n\n        /**\n         * Saves the expanded state of panel chats.\n         */\n        function saveExpandedPanelChats() {\n            expandedPanelChats.clear();\n            document.querySelectorAll('.panel-chat-details').forEach((details) => {\n                const parentHeader = details.previousElementSibling;\n                if (details.style.display === 'block' && parentHeader) {\n                    const panelChatId = parentHeader.getAttribute('data-panel-chat-id');\n                    if (panelChatId) {\n                        expandedPanelChats.add(panelChatId);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Restores the expanded state of panel chats.\n         */\n        function restoreExpandedPanelChats() {\n            document.querySelectorAll('.panel-chat-details').forEach((details) => {\n                const parentHeader = details.previousElementSibling;\n                if (parentHeader) {\n                    const panelChatId = parentHeader.getAttribute('data-panel-chat-id');\n                    if (panelChatId && expandedPanelChats.has(panelChatId)) {\n                        details.style.display = 'block';\n                    }\n                }\n            });\n        }\n\n        /**\n         * Handles incoming messages from the extension backend.\n         */\n        window.addEventListener('message', event => {\n            const message = event.data;\n            if (message.type === 'update') {\n                saveScrollPosition();\n                saveExpandedCommits();\n                saveExpandedPanelChats(); // Save expanded panel chats\n\n                const contentElement = document.getElementById('content');\n                contentElement.innerHTML = ''; // Clear existing content\n\n                if (message.commits && message.commits.length > 0) {\n                    message.commits.forEach(commit => {\n                        // Create commit container\n                        const commitDiv = document.createElement('div');\n                        commitDiv.className = 'commit';\n\n                        // Create commit header\n                        const commitHeader = document.createElement('div');\n                        commitHeader.className = 'commit-header';\n\n                        const isRegularCommit = commit.commitHash !== 'added' && commit.commitHash !== 'uncommitted';\n\n                        const commitMessage = isRegularCommit\n                        ? \\`\\${escapeHtml(commit.commitMessage)}\\`\n                        : \\`\\${escapeHtml(commit.commitMessage)}\\`;\n\n\n                        commitHeader.innerHTML = \\`\n                            <h3>\\${escapeHtml(commitMessage)}</h3>\n                            <span class=\"commit-date\">\\${new Date(commit.date).toLocaleString()}</span>\n                        \\`;\n\n                        commitDiv.appendChild(commitHeader);\n\n                        // Create commit details container\n                        const commitDetails = document.createElement('div');\n                        commitDetails.className = 'commit-details';\n\n                        // Populate panelChats\n                        if (commit.panelChats && commit.panelChats.length > 0) {\n                            commit.panelChats.forEach(panelChat => {\n                                // Create panelChat container\n                                const panelChatDiv = document.createElement('div');\n                                panelChatDiv.className = 'panel-chat';\n\n                                // PanelChat header with delete and append buttons\n                                const panelChatHeader = document.createElement('div');\n                                panelChatHeader.className = 'panel-chat-header';\n                                // When setting the data attribute for panelChat headers\n                                panelChatHeader.setAttribute('data-panel-chat-id', \\`\\${commit.commitHash}-\\${panelChat.id}\\`); // Add data attribute for identification\n                                panelChatHeader.innerHTML = \\`\n                                    Title: \\${escapeHtml(panelChat.customTitle)}\n                                    <button class=\"delete-panelchat-button\" data-id=\"\\${escapeHtml(panelChat.id)}\" title=\"Delete PanelChat\">🗑️</button>\n                                    <button \n                                        class=\"append-context-button\" \n                                        data-commit=\"\\${escapeHtml(commit.commitHash)}\" \n                                        data-id=\"\\${escapeHtml(panelChat.id)}\" \n                                        title=\"Append to context\"\n                                    >\n                                        📄\n                                    </button>\n                                \\`;\n\n                                // Determine if the commit is an uncommitted change\n                                const isUnadded = commit.commitHash === 'uncommitted';\n\n                                if (isUnadded) {\n                                    // Add Write Chat Button for Uncommitted Changes\n                                    panelChatHeader.innerHTML += \\`\n                                        <button \n                                            class=\"write-chat-button\" \n                                            data-panel-chat-id=\"\\${escapeHtml(panelChat.id)}\" \n                                            title=\"Write PanelChat to Stashed State\"\n                                        >\n                                            ➕\n                                        </button>\n                                    \\`;\n                                } else if (commit.commitHash === 'added') {\n                                    // Add Remove Chat Button for Added Changes\n                                    panelChatHeader.innerHTML += \\`\n                                        <button \n                                            class=\"remove-chat-button\" \n                                            data-panel-chat-id=\"\\${escapeHtml(panelChat.id)}\" \n                                            title=\"Remove PanelChat from Stashed State\"\n                                        >\n                                            ➖\n                                        </button>\n                                    \\`;\n                                }\n\n                                panelChatDiv.appendChild(panelChatHeader);\n\n                                // Create panel-chat-details container\n                                const panelChatDetails = document.createElement('div');\n                                panelChatDetails.className = 'panel-chat-details';\n\n                                // PanelChat info (customTitle, ai_editor, etc.)\n                                const panelChatInfo = document.createElement('div');\n                                panelChatInfo.className = 'panel-chat-info';\n                                panelChatInfo.innerHTML = \\`\n                                    <strong>AI Editor:</strong> \\${escapeHtml(panelChat.ai_editor)}<br>\n                                    <strong>Created On:</strong> \\${new Date(panelChat.created_on).toLocaleString()}<br>\n                                \\`;\n                                panelChatDetails.appendChild(panelChatInfo);\n\n                                // Messages in panelChat\n                                panelChat.messages.forEach(messageEntry => {\n                                    const messageContainer = document.createElement('div');\n                                    messageContainer.className = 'message-container';\n\n                                    // Delete button\n                                    const deleteBtn = document.createElement('button');\n                                    deleteBtn.className = 'delete-button';\n                                    deleteBtn.setAttribute('data-id', messageEntry.id);\n                                    deleteBtn.title = 'Delete Message';\n                                    deleteBtn.textContent = '×';\n                                    messageContainer.appendChild(deleteBtn);\n\n                                    // Determine if the commit is an uncommitted change\n                                    const isUnaddedMessage = commit.commitHash === 'uncommitted';\n\n                                    // Conditionally add Write or Remove Chat Buttons\n                                    if (isUnaddedMessage) {\n                                        // Add Write Chat Button for Messages\n                                        const writeBtn = document.createElement('button');\n                                        writeBtn.className = 'write-chat-button';\n                                        writeBtn.setAttribute('data-message-id', messageEntry.id); // Changed to 'data-message-id'\n                                        writeBtn.title = 'Write Message to Stashed State';\n                                        writeBtn.textContent = '➕';\n                                        messageContainer.appendChild(writeBtn);\n                                    } else if (commit.commitHash === 'added') {\n                                        // Add Remove Chat Button for Messages\n                                        const removeBtn = document.createElement('button');\n                                        removeBtn.className = 'remove-chat-button';\n                                        removeBtn.setAttribute('data-message-id', messageEntry.id); // Changed to 'data-message-id'\n                                        removeBtn.title = 'Remove Message from Stashed State';\n                                        removeBtn.textContent = '➖';\n                                        messageContainer.appendChild(removeBtn);\n                                    }\n\n                                    // Message Text\n                                    const messageDiv = document.createElement('div');\n                                    messageDiv.className = 'message';\n                                    messageDiv.innerHTML = escapeHtml(messageEntry.messageText);\n                                    messageContainer.appendChild(messageDiv);\n\n                                    // Response Text\n                                    const responseDiv = document.createElement('div');\n                                    responseDiv.className = 'response';\n                                    responseDiv.innerHTML = formatResponse(messageEntry.responseText);\n                                    messageContainer.appendChild(responseDiv);\n\n                                    // Additional Message Details\n                                    const messageDetails = document.createElement('div');\n                                    messageDetails.className = 'message-details';\n                                    messageDetails.style.fontSize = '0.8em';\n                                    messageDetails.style.color = 'var(--vscode-descriptionForeground)';\n                                    messageDetails.innerHTML = \\`\n                                        <strong>Model:</strong> \\${escapeHtml(messageEntry.model)}<br>\n                                        <strong>Timestamp:</strong> \\${new Date(messageEntry.timestamp).toLocaleString()}\n                                    \\`;\n                                    messageContainer.appendChild(messageDetails);\n\n                                    // Optionally, display context if needed\n                                    console.log('Message Entry Context:', messageEntry.context);\n                                    if (messageEntry.context && Array.isArray(messageEntry.context) && messageEntry.context.length > 0) {\n                                        const contextDiv = document.createElement('div');\n                                        contextDiv.className = 'context';\n                                        contextDiv.style.fontSize = '0.8em';\n                                        contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                                        const humanReadableContext = messageEntry.context\n                                        .filter(item => item && typeof item === 'object' && item.value && typeof item.value === 'object' && typeof item.value.human_readable === 'string')\n                                        .map(item => {\n                                            // Get the relative path\n                                            const fullPath = item.value.human_readable;\n                                            let relativePath = fullPath;\n                                            \n                                            if (workspaceFolderPath && fullPath.startsWith(workspaceFolderPath)) {\n                                                relativePath = fullPath.slice(workspaceFolderPath.length + 1);\n                                            }\n\n                                            const link = document.createElement('a');\n                                            link.href = '#';\n                                            link.textContent = escapeHtml(relativePath);\n                                            link.dataset.path = relativePath;\n                                            link.classList.add('context-link'); \n                                            return link.outerHTML;\n                                        })\n                                        .join(', ');\n                                        if (humanReadableContext) {\n                                            contextDiv.innerHTML = \\`<strong>Context:</strong> \\${humanReadableContext}\\`;\n                                            messageContainer.appendChild(contextDiv);\n                                        }\n                                    }\n\n                                    if (messageEntry.kv_store && 'file_paths' in messageEntry.kv_store) {\n                                        const contextDiv = document.createElement('div');\n                                        contextDiv.className = 'context';\n                                        contextDiv.style.fontSize = '0.8em';\n                                        contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                                        const associatedFilePaths = messageEntry.kv_store.file_paths\n                                        .map(filePath => {\n                                            let relativePath = filePath;\n                                            \n                                            if (workspaceFolderPath && filePath.startsWith(workspaceFolderPath)) {\n                                                relativePath = filePath.slice(workspaceFolderPath.length + 1);\n                                            }\n\n                                            const link = document.createElement('a');\n                                            link.href = '#';\n                                            link.textContent = escapeHtml(relativePath);\n                                            link.dataset.path = relativePath;\n                                            link.classList.add('context-link'); \n                                            return link.outerHTML;\n                                        })\n                                        .join(', ');\n                                        if (associatedFilePaths) {\n                                            contextDiv.innerHTML = \\`<strong>Associated Files:</strong> \\${associatedFilePaths}\\`;\n                                            messageContainer.appendChild(contextDiv);\n                                        }\n                                    }\n\n                                    panelChatDetails.appendChild(messageContainer);\n                                });\n\n                                commitDetails.appendChild(panelChatDetails);\n                                panelChatDiv.appendChild(panelChatDetails);\n\n                                commitDetails.appendChild(panelChatDiv);\n                            });\n                        } else {\n                            const noPanelChats = document.createElement('div');\n                            noPanelChats.className = 'no-messages';\n                            noPanelChats.textContent = 'No panelChats in this commit.';\n                            commitDetails.appendChild(noPanelChats);\n                        }\n\n                        commitDiv.appendChild(commitDetails);\n                        contentElement.appendChild(commitDiv);\n                    });\n\n                    // Attach event listeners for collapsible commits\n                    attachCommitToggleListeners();\n\n                    // Attach event listeners for collapsible panel chats\n                    attachPanelChatToggleListeners(); // New function call\n\n                    // Attach event listeners for delete, write, and remove buttons\n                    attachButtonListeners();\n\n                    attachLinkListeners();\n                } else {\n                    const noCommits = document.createElement('div');\n                    noCommits.className = 'no-commits';\n                    noCommits.textContent = 'No commits found.';\n                    contentElement.appendChild(noCommits);\n                }\n\n                // After updating the content\n                restoreExpandedCommits();\n                restoreExpandedPanelChats(); // Restore expanded panel chats\n                restoreScrollPosition();\n                Prism.highlightAll();\n            }\n        });\n\n        /**\n         * Notifies the extension that the Webview is ready.\n         */\n        // Notify the extension that the Webview is ready\n        vscode.postMessage({ command: 'webviewReady' });\n        //console.log('Webview is ready.');\n    </script>\n</body>\n</html>\n        `;\n    }\n\n}\n\n/**\n * Generates a random nonce for Content Security Policy.\n * @returns {string} - A random 32-character string.\n */\nfunction getNonce() {\n    let text = '';\n    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    for (let i = 0; i < 32; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n}\n",
          "after_content": "import * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport { CommitData, GitHistoryData, getGitHistory, getGitHistoryThatTouchesFile } from './panelgit';\nimport { PanelChat } from './types';\nimport { readStashedState, writeStashedState, removeMessageFromStashedState, removePanelChatFromStashedState, writeChatToStashedState } from './stashedState';\nimport { panelChatsToMarkdown } from './markdown'; // Added import\nimport { STASHED_GAIT_STATE_FILE_NAME } from './constants';\nimport posthog from 'posthog-js';\nimport { identifyUser } from './identify_user';\n\nexport class PanelViewProvider implements vscode.WebviewViewProvider {\n    public static readonly viewType = 'gait-copilot.panelView';\n\n    private _view?: vscode.WebviewView;\n    private _commits: CommitData[] = [];\n    private _isFilteredView: boolean = false; // New state to track view type\n\n    /**\n     * Loads commits and integrates uncommitted changes into the commits array.\n     * Supports both default and filtered views based on _isFilteredView.\n     */\n    private async loadCommitsAndChats(additionalFilePath?: string) {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n            //vscode.window.showErrorMessage('No workspace folder found.');\n            return;\n        }\n        let context = this._context;\n\n        const repoPath = workspaceFolder.uri.fsPath;\n        const filePath = `.gait/${STASHED_GAIT_STATE_FILE_NAME}`; // Replace with your actual file path relative to repo\n\n        try {\n            if (this._isFilteredView && additionalFilePath) {\n                const gitHistory: GitHistoryData = await getGitHistoryThatTouchesFile(this._context, repoPath, filePath, additionalFilePath);\n\n                // Map CommitData from getGitHistoryThatTouchesFile to the class's commit structure\n                this._commits = gitHistory.commits.map(commit => ({\n                    commitHash: commit.commitHash,\n                    commitMessage: commit.commitMessage,\n                    author: commit.author,\n                    date: new Date(commit.date),\n                    panelChats: commit.panelChats,\n                    inlineChats: commit.inlineChats\n                })).sort((a, b) => b.date.getTime() - a.date.getTime());\n\n                if (gitHistory.added) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'added',\n                        author: 'You',\n                        commitMessage: 'Added Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.added.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.added.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n                else{\n                    console.log(\"No added changes\");\n                }\n\n                // Handle uncommitted changes by appending them to the commits array\n                if (gitHistory.uncommitted) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'uncommitted',\n                        author: 'You',\n                        commitMessage: 'Unadded Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.uncommitted.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.uncommitted.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n            } else {\n                const gitHistory: GitHistoryData = await getGitHistory(this._context, repoPath, filePath);\n\n                // Map CommitData from getGitHistory to the class's commit structure\n                this._commits = gitHistory.commits.map(commit => ({\n                    commitHash: commit.commitHash,\n                    commitMessage: commit.commitMessage,\n                    author: commit.author,\n                    date: new Date(commit.date),\n                    panelChats: commit.panelChats,\n                    inlineChats: commit.inlineChats\n                })).sort((a, b) => b.date.getTime() - a.date.getTime());\n\n                if (gitHistory.added) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'added',\n                        author: 'You',\n                        commitMessage: 'Added Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.added.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.added.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n\n                // Handle uncommitted changes by appending them to the commits array\n                if (gitHistory.uncommitted) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'uncommitted',\n                        author: 'You',\n                        commitMessage: 'Unadded Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.uncommitted.panelChats,\n                        inlineChats: gitHistory.uncommitted.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n            }\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Error loading git history: ${error.message}`);\n            this._commits = [];\n        }\n    }\n\n    /**\n     * Updates the webview content by loading commits and integrating uncommitted changes.\n     */\n    public async updateContent() {\n\n        if (this._isFilteredView) {\n            const editor = vscode.window.activeTextEditor;\n            if (editor) {\n                const document = editor.document;\n                const filePath = vscode.workspace.asRelativePath(document.uri.fsPath);\n                await this.loadCommitsAndChats(filePath);\n            }\n        } else {\n            await this.loadCommitsAndChats();\n        }\n        if (this._view) {\n            this._view.webview.postMessage({\n                type: 'update',\n                commits: this._commits,\n            });\n        }\n    }\n\n    constructor(private readonly _context: vscode.ExtensionContext) {\n        // Initialize by loading commits and chats\n        this.loadCommitsAndChats().catch(error => {\n            vscode.window.showErrorMessage(`Initialization error: ${(error as Error).message}`);\n        });\n    }\n\n    private async handleDeletePanelChat(panelChatId: string) {\n        const stashedState = readStashedState(this._context);\n        stashedState.deletedChats.deletedPanelChatIDs.push(panelChatId);\n        writeStashedState(this._context, stashedState);\n    }\n\n    private async handleRemovePanelChatFromStashedState(panelChatId: string) {\n        console.log(`Removing panelChat with ID ${panelChatId} from stashed state.`);\n        removePanelChatFromStashedState(this._context, panelChatId);\n    }\n\n    private async handleRemoveMessageFromStashedState(messageId: string) {\n        console.log(`Removing message with ID ${messageId} from stashed state.`);\n        removeMessageFromStashedState(this._context, messageId);\n    }\n\n    private async handleWriteChatToStashedState(panelChatId?: string, messageId?: string) {\n        if ((panelChatId && messageId) || (!panelChatId && !messageId)) {\n            vscode.window.showErrorMessage('Invalid parameters: Provide either panelChatId or messageId, but not both.');\n            if (panelChatId && messageId) {\n                vscode.window.showErrorMessage('Both panelChatId and messageId provided. Please provide only one.');\n            }\n            else {\n                vscode.window.showErrorMessage('No panelChatId or messageId provided. Please provide one.');\n            }\n            return;\n        }\n\n        try {\n            if (panelChatId) {\n                // Find the PanelChat with the given panelChatId\n                    const panelChat = this._commits[0].panelChats.find(pc => pc.id === panelChatId);\n                    if (panelChat) {\n                        // Write the entire PanelChat to stashed state\n                        await writeChatToStashedState(this._context, panelChat);\n                        vscode.window.showInformationMessage(`PanelChat with ID ${panelChatId} has been stashed.`);\n                        return;\n                    }\n                \n                vscode.window.showErrorMessage(`PanelChat with ID ${panelChatId} not found.`);\n            } else if (messageId) {\n                // Find the MessageEntry with the given messageId\n                    for (const panelChat of this._commits[0].panelChats) {\n                        const message = panelChat.messages.find(msg => msg.id === messageId);\n                        if (message) {\n                            // Construct a new PanelChat containing only this message\n                            const newPanelChat: PanelChat = {\n                                ai_editor: panelChat.ai_editor,\n                                id: panelChat.id,\n                                customTitle: `Stashed Message ${message.id}`,\n                                parent_id: null,\n                                created_on: new Date().toISOString(),\n                                messages: [message],\n                                kv_store: {}\n                            };\n                            // Write the new PanelChat to stashed state\n                            await writeChatToStashedState(this._context, newPanelChat);\n                            vscode.window.showInformationMessage(`Message with ID ${messageId} has been stashed.`);\n                            return;\n                        }\n                    \n                }\n                vscode.window.showErrorMessage(`Message with ID ${messageId} not found.`);\n            }\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to write chat to stashed state: ${error.message}`);\n            console.error(`Error in handleWriteChatToStashedState: ${error.stack}`);\n        }\n    }\n\n    public resolveWebviewView(\n        webviewView: vscode.WebviewView,\n        context: vscode.WebviewViewResolveContext,\n        _token: vscode.CancellationToken\n    ) {\n        identifyUser(this._context);\n        posthog.capture('$pageview');\n        this._view = webviewView;\n        // Add analytics for the number of inlineChats and panelChats saved\n        const stashedState = readStashedState(this._context);\n        const panelChatsCount = stashedState.panelChats.length;\n        const inlineChatsCount = stashedState.inlineChats.length;\n        \n        posthog.capture('panel_view_opened', {\n            panelChatsCount: panelChatsCount,\n            inlineChatsCount: inlineChatsCount\n        });\n\n        webviewView.webview.options = {\n            enableScripts: true,\n        };\n\n        webviewView.webview.html = this.getHtmlForWebview(webviewView.webview);\n\n        webviewView.webview.onDidReceiveMessage(message => {\n            switch (message.command) {\n                case 'webviewReady':\n                    this.updateContent();\n                    break;\n                case 'deleteMessage':\n                    posthog.capture('delete_message');\n                    this.handleDeleteMessage(message.id);\n                    this.updateContent();\n                    break;\n                case 'deletePanelChat':\n                    posthog.capture('delete_panelchat');\n                    this.handleDeletePanelChat(message.id);\n                    this.updateContent();\n                    break;\n                case 'refresh':\n                    this.updateContent();\n                    break;\n                case 'switchView':\n                    this.handleSwitchView(message.view);\n                    break;\n                case 'appendContext': // New case for appending context\n                    this.handleAppendContext(message.commitHash, message.panelChatId);\n                    break;\n                case 'writeChatToStashedState': // New case for writing chat to stashed state\n                    this.handleWriteChatToStashedState(message.panelChatId, message.messageId);\n                    posthog.capture('manual_stage');\n                    this.updateContent();\n                    break;                \n                case 'removePanelChatFromStashedState': // New case for removing panelChat from stashed state\n                    this.handleRemovePanelChatFromStashedState(message.panelChatId);\n                    posthog.capture('manual_unstage');\n                    this.updateContent();\n                    break;\n                case 'removeMessageFromStashedState': // New case for removing message from stashed state\n                    this.handleRemoveMessageFromStashedState(message.messageId);\n                    this.updateContent();\n                    break;\n                case 'openFile':\n                    this.handleOpenFile(message.path);\n                    break;\n                default:\n                    break;\n            }\n        });\n\n        webviewView.onDidChangeVisibility(() => {\n            if (webviewView.visible) {\n                this.updateContent();\n            }\n        });\n    }\n\n    /**\n     * Handles switching between default and filtered views based on user selection.\n     * @param view - The selected view type.\n     */\n    private async handleSwitchView(view: string) {\n        if (view === 'filtered') {\n            this._isFilteredView = true;\n            //await this.updateContent();\n        } else {\n            // Default view\n            this._isFilteredView = false;\n        }\n        await this.updateContent();\n    }\n\n    /**\n     * Handles the deletion of a message by its ID.\n     * @param messageId - The ID of the message to delete.\n     */\n    private async handleDeleteMessage(messageId: string) {\n        const stashedState = readStashedState(this._context);\n        stashedState.deletedChats.deletedMessageIDs.push(messageId);\n        writeStashedState(this._context, stashedState);\n    }\n\n    /**\n     * Handles appending panelChat messages to gaitContext.md\n     * @param commitHash - The hash of the commit containing the panelChat.\n     * @param panelChatId - The ID of the panelChat to append.\n     */\n    private async handleAppendContext(commitHash: string, panelChatId: string) {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n            //vscode.window.showErrorMessage('No workspace folder found.');\n            return;\n        }\n\n        const repoPath = workspaceFolder.uri.fsPath;\n        const filePath = path.join(repoPath, 'gait_context.md');\n\n        try {\n            // Ensure the file exists; if not, create it with a header\n            if (!fs.existsSync(filePath)) {\n                fs.writeFileSync(filePath, '# Gait Context\\n\\n', 'utf-8');\n            }\n\n            // Find the specific commit\n            const targetCommit = this._commits.find(commit => commit.commitHash === commitHash);\n            if (!targetCommit) {\n                vscode.window.showErrorMessage(`Commit with hash ${commitHash} not found.`);\n                return;\n            }\n\n            // Find the specific panelChat within the commit\n            const targetPanelChat = targetCommit.panelChats.find(pc => pc.id === panelChatId);\n            if (!targetPanelChat) {\n                vscode.window.showErrorMessage(`PanelChat with ID ${panelChatId} not found in commit ${commitHash}.`);\n                return;\n            }\n\n            // Convert the panelChat to Markdown\n            const markdownContent = panelChatsToMarkdown([{ commit: targetCommit, panelChat: targetPanelChat }]);\n\n            // Append the markdown content to gaitContext.md\n            fs.appendFileSync(filePath, markdownContent + '\\n\\n', 'utf-8');\n            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(filePath), { viewColumn: vscode.ViewColumn.Beside });\n            await vscode.commands.executeCommand('aichat.newchataction');\n\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to append context: ${error.message}`);\n            console.error(`Error appending context: ${error.stack}`);\n        }\n    }\n\n    /**\n     * Handles opening a file in the editor.\n     * @param filePath - The path of the file to open.\n     */\n    private async handleOpenFile(filePath: string) {\n        console.log(`Opening file: ${filePath}`);\n        try {\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n            if (!workspaceFolder) {\n                vscode.window.showErrorMessage('No workspace folder found.');\n                return;\n            }\n\n            const fullPath = vscode.Uri.file(path.join(workspaceFolder.uri.fsPath, filePath));\n            const document = await vscode.workspace.openTextDocument(fullPath);\n            await vscode.window.showTextDocument(document);\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to open file: ${error.message}`);\n        }\n    }\n\n    /**\n     * Generates the HTML content for the webview, including a dropdown for view selection.\n     * @param webview - The Webview instance.\n     * @returns A string containing the HTML.\n     */\n    private getHtmlForWebview(webview: vscode.Webview): string {\n        const nonce = getNonce();\n        const prismCssPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'prism.css');\n        const prismJsPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'prism.js');\n        const markedJsPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'marked.js'); // Path to Marked.js\n        const prismCssUri = webview.asWebviewUri(prismCssPath);\n        const prismJsUri = webview.asWebviewUri(prismJsPath);\n        const markedJsUri = webview.asWebviewUri(markedJsPath); // URI for Marked.js\n        const workspaceFolderPath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\n\n        return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <script>\n    !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(\".\");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement(\"script\")).type=\"text/javascript\",p.async=!0,p.src=s.api_host.replace(\".i.posthog.com\",\"-assets.i.posthog.com\")+\"/static/array.js\",(r=t.getElementsByTagName(\"script\")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a=\"posthog\",u.people=u.people||[],u.toString=function(t){var e=\"posthog\";return\"posthog\"!==a&&(e+=\".\"+a),t||(e+=\" (stub)\"),e},u.people.toString=function(){return u.toString(1)+\".people (stub)\"},o=\"capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys getNextSurveyStep onSessionId\".split(\" \"),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);\n    posthog.init('phc_vosMtvFFxCN470e8uHGDYCD6YuuSRSoFoZeLuciujry',{api_host:'https://us.i.posthog.com',})\n    </script>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Git Commit History</title>\n    \n <!-- Content Security Policy -->\n    <meta http-equiv=\"Content-Security-Policy\" content=\"\n        default-src 'none';\n        style-src 'nonce-${nonce}' ${webview.cspSource};\n        script-src 'nonce-${nonce}' ${webview.cspSource};\n        connect-src 'self';\n        img-src 'self';\n        font-src 'self';\n    \">\n    \n    <!-- Prism.js CSS -->\n    <link href=\"${prismCssUri}\" rel=\"stylesheet\" />\n    <!-- Marked.js -->\n    <script src=\"${markedJsUri}\" nonce=\"${nonce}\"></script>\n\n    <style nonce=\"${nonce}\">\n        body {\n            font-family: var(--vscode-font-family);\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n            padding: 0;\n            margin: 0;\n            overflow: auto;\n        }\n        .container {\n            max-width: 1000px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        .header {\n            background-color: var(--vscode-titleBar-activeBackground);\n            color: var(--vscode-titleBar-activeForeground);\n            padding: 15px;\n            border-radius: 5px 5px 0 0;\n            margin-bottom: 20px;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n        }\n        .header h2 {\n            margin: 0;\n            font-size: 1.5em;\n        }\n        .commit {\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            padding: 15px;\n            margin-bottom: 15px;\n            background-color: var(--vscode-editor-inactiveSelectionBackground);\n        }\n        .commit-date {\n            color: var(--vscode-descriptionForeground);\n            font-size: 0.9em;\n        }\n        .commit-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            cursor: pointer;\n        }\n        .commit-header:hover {\n            background-color: var(--vscode-editor-selectionBackground);\n        }\n        .commit-header h3 {\n            margin: 0;\n            font-size: 1.2em;\n        }\n        .commit-details {\n            display: none;\n            margin-top: 10px;\n        }\n        .panel-chat {\n            margin-bottom: 15px;\n            padding: 10px;\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            background-color: var(--vscode-editor-background);\n        }\n        .panel-chat-header {\n            font-weight: bold;\n            margin-bottom: 5px;\n            display: flex;\n            align-items: center;\n            cursor: pointer; /* Make it clickable */\n        }\n        .panel-chat-header:hover {\n            background-color: var(--vscode-editor-selectionBackground);\n        }\n        .panel-chat-info {\n            font-size: 0.9em;\n            color: var(--vscode-descriptionForeground);\n            margin-bottom: 10px;\n        }\n        .panel-chat-details {\n            display: none; /* Hidden by default */\n            margin-top: 10px;\n        }\n        .message-container {\n            margin-bottom: 15px;\n            position: relative;\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            padding: 10px;\n            background-color: var(--vscode-editor-background);\n        }\n        .delete-button {\n            position: absolute;\n            top: 10px;\n            right: 10px;\n            background: transparent;\n            border: none;\n            color: red;\n            font-weight: bold;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        .delete-panelchat-button {\n            background: transparent;\n            border: none;\n            color: red;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .delete-panelchat-button:hover {\n            color: darkred;\n        }\n        .append-context-button {\n            background: transparent;\n            border: none;\n            color: blue;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .append-context-button:hover {\n            color: darkblue;\n        }\n        .write-chat-button {\n            background: transparent;\n            border: none;\n            color: green;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .write-chat-button:hover {\n            color: darkgreen;\n        }\n        .remove-chat-button {\n            background: transparent;\n            border: none;\n            color: orange;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .remove-chat-button:hover {\n            color: darkorange;\n        }\n        .message, .response {\n            padding: 10px;\n            border-radius: 5px;\n            margin-bottom: 5px;\n        }\n        .message {\n            background-color: var(--vscode-editor-selectionBackground);\n            word-wrap: break-word;\n        }\n        .response {\n            background-color: var(--vscode-editorWidget-background);\n            word-wrap: break-word;\n        }\n        pre {\n            background-color: var(--vscode-textCodeBlock-background);\n            padding: 8px;\n            border-radius: 3px;\n            font-family: var(--vscode-editor-font-family);\n            overflow-x: auto;\n        }\n        code {\n            font-family: var(--vscode-editor-font-family);\n            font-size: 0.9em;\n        }\n        .no-commits, .no-messages {\n            text-align: center;\n            color: var(--vscode-editorError-foreground);\n            font-style: italic;\n            margin-top: 20px;\n        }\n\n        /* Dropdown Styles */\n        .dropdown-container {\n            margin-bottom: 20px;\n            display: flex;\n            justify-content: flex-end;\n            align-items: center;\n        }\n\n        .dropdown-container label {\n            margin-right: 10px;\n            font-weight: bold;\n        }\n\n        .dropdown-container select {\n            padding: 5px;\n            border-radius: 4px;\n            border: 1px solid var(--vscode-editorWidget-border);\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n        }\n\n        /* Modal Styles */\n        .modal {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            z-index: 1000; /* Ensure it's on top */\n        }\n\n        .modal-content {\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n            padding: 20px;\n            border-radius: 8px;\n            width: 300px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n\n        .modal-buttons {\n            display: flex;\n            justify-content: flex-end;\n            margin-top: 20px;\n        }\n\n        .modal-buttons button {\n            margin-left: 10px;\n            padding: 5px 10px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n\n        #confirmYes {\n            background-color: var(--vscode-button-background);\n            color: var(--vscode-button-foreground);\n        }\n\n        #confirmNo {\n            background-color: var(--vscode-button-secondaryBackground);\n            color: var(--vscode-button-secondaryForeground);\n        }\n\n        .hidden {\n            display: none;\n        }\n\n        .visible {\n            display: flex; /* or block, depending on your layout needs */\n        }\n\n\n        /* Override Prism.js styles if necessary */\n        /* Example: Adjusting code block background */\n        pre[class*=\"language-\"] {\n            background: var(--vscode-textCodeBlock-background) !important;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h2>Git Commit History</h2>\n            <button id=\"refreshButton\" title=\"Refresh Commit History\">🔄</button>\n        </div>\n\n        <!-- Dropdown for selecting view -->\n        <div class=\"dropdown-container\">\n            <label for=\"viewSelect\">View:</label>\n            <select id=\"viewSelect\">\n                <option value=\"default\">All Commits</option>\n                <option value=\"filtered\">Commits Touching Specific File</option>\n            </select>\n        </div>\n\n        <div id=\"content\">\n            <div class=\"no-commits\">Loading commit history...</div>\n        </div>\n    </div>\n\n    <!-- Confirmation Modal -->\n    <div id=\"confirmModal\" class=\"modal hidden\">\n        <div class=\"modal-content\">\n            <p>Are you sure you want to delete this item?</p>\n            <div class=\"modal-buttons\">\n                <button id=\"confirmYes\">Yes</button>\n                <button id=\"confirmNo\">No</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Prism.js JS -->\n    <script src=\"${prismJsUri}\" nonce=\"${nonce}\"> </script>\n\n    <script nonce=\"${nonce}\">\n\n        setInterval(() => {\n            vscode.postMessage({ command: 'refresh' });\n        }, 3000);\n\n        const vscode = acquireVsCodeApi();\n        const workspaceFolderPath = '${workspaceFolderPath}';\n\n        /**\n         * Escapes HTML characters to prevent XSS attacks.\n         * @param {string} text - The text to escape.\n         * @returns {string} - The escaped text.\n         */\n        function escapeHtml(text) {\n            const map = {\n                '&': '&amp;',\n                '<': '&lt;',\n                '>': '&gt;',\n                '\"': '&quot;',\n                \"'\": '&#039;'\n            };\n            return text.replace(/[&<>\"']/g, function(m) { return map[m]; });\n        }\n\n        function formatResponse(responseText) {\n            if (typeof responseText !== 'string') {\n                console.warn('formatResponse received non-string responseText:', responseText);\n                return '<em>Invalid response text.</em>';\n            }\n\n            // Enhanced regex to handle optional newline after language specifier\n            const codeBlockRegex = /\\`\\`\\`(\\\\w+)?\\\\n?([\\\\s\\\\S]+?)\\`\\`\\`/g;\n            let formattedText = '';\n            let lastIndex = 0;\n            let match;\n            let matchFound = false;\n\n            console.warn('Response text:', responseText); // Debugging log\n\n            while ((match = codeBlockRegex.exec(responseText)) !== null) {\n                matchFound = true;\n                const index = match.index;\n                console.warn('Matched code block:', match[0]); // Debugging log\n\n                // Escape and append text before the code block\n                formattedText += escapeHtml(responseText.slice(lastIndex, index));\n\n                const language = match[1] ? match[1].trim().replace(/\\\\n+$/, '') : '';\n                const code = match[2] ? escapeHtml(match[2].trim()) : '';\n\n                console.warn('Language', JSON.stringify(language));// Debugging log\n                console.warn('Code', JSON.stringify(code)); // Debugging log\n\n                // Append the formatted code block\n                formattedText += \\`<pre><code class=\"language-\\${language}\">\\${code}</code></pre>\\`;\n\n                lastIndex = index + match[0].length;\n            }\n\n            if (!matchFound) {\n                console.warn('No code blocks found in responseText.');\n            }\n\n            // Escape and append the remaining text after the last code block\n            formattedText += marked.parse(escapeHtml(responseText.slice(lastIndex)));\n            return formattedText;\n        }\n\n\n        /**\n         * Attaches click listeners to commit headers to toggle visibility of commit details.\n         */\n        function attachCommitToggleListeners() {\n            const commitHeaders = document.querySelectorAll('.commit-header');\n            commitHeaders.forEach(header => {\n                header.addEventListener('click', () => {\n                    const details = header.nextElementSibling;\n                    if (details) {\n                        if (details.style.display === 'block') {\n                            details.style.display = 'none';\n                        } else {\n                            details.style.display = 'block';\n                            const codeBlocks = details.querySelectorAll('pre code');\n                            console.log('Found code blocks:', codeBlocks);\n                            codeBlocks.forEach((block) => {\n                                Prism.highlightElement(block);\n                            });\n                        }\n                    }\n                });\n            });\n        }\n\n        /**\n         * Attaches click listeners to panel chat headers to toggle visibility of panel chat details.\n         */\n        function attachPanelChatToggleListeners() {\n            const panelChatHeaders = document.querySelectorAll('.panel-chat-header');\n            panelChatHeaders.forEach(header => {\n                header.addEventListener('click', () => {\n                    const details = header.nextElementSibling;\n                    if (details) {\n                        if (details.style.display === 'block') {\n                            details.style.display = 'none';\n                        } else {\n                            details.style.display = 'block';\n                            const codeBlocks = details.querySelectorAll('pre code');\n                            console.log('Found code blocks in panel chat:', codeBlocks);\n                            codeBlocks.forEach((block) => {\n                                Prism.highlightElement(block);\n                            });\n                        }\n                    }\n                });\n            });\n        }\n\n        function attachLinkListeners() {\n            const contentElement = document.getElementById('content');\n            contentElement.addEventListener('click', (event) => {\n                const target = event.target;\n                if (target && target.matches('a.context-link')) {\n                    event.preventDefault();\n                    const path = target.dataset.path;\n                    if (path) {\n                        console.log('Context link clicked:', path);\n                        vscode.postMessage({ command: 'openFile', path: path });\n                    } else {\n                        console.warn('Clicked link does not have a data-path attribute.');\n                    }\n                }\n            });\n        }\n\n        /**\n         * Attaches click listeners to delete, write, and remove buttons to handle respective actions.\n         */\n        function attachButtonListeners() {\n            // Existing Delete Message Buttons\n            const deleteMessageButtons = document.querySelectorAll('.delete-button');\n            deleteMessageButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const messageId = button.getAttribute('data-id');\n                    if (messageId) {\n                        showConfirmationModal('message', messageId);\n                    } else {\n                        console.warn('Delete button clicked without a valid message ID.');\n                    }\n                });\n            });\n\n            // Existing Delete PanelChat Buttons\n            const deletePanelChatButtons = document.querySelectorAll('.delete-panelchat-button');\n            deletePanelChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const panelChatId = button.getAttribute('data-id');\n                    if (panelChatId) {\n                        showConfirmationModal('panelChat', panelChatId);\n                    } else {\n                        console.warn('Delete PanelChat button clicked without a valid PanelChat ID.');\n                    }\n                });\n            });\n\n            // New Append to gaitContext.md Buttons\n            const appendContextButtons = document.querySelectorAll('.append-context-button');\n            appendContextButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const commitHash = button.getAttribute('data-commit');\n                    const panelChatId = button.getAttribute('data-id');\n                    if (commitHash && panelChatId) {\n                        vscode.postMessage({ \n                            command: 'appendContext', \n                            commitHash: commitHash, \n                            panelChatId: panelChatId \n                        });\n                    } else {\n                        console.warn('Append Context button clicked without valid commitHash or PanelChat ID.');\n                    }\n                });\n            });\n\n            // New Write Chat Buttons for Unadded Changes\n            const writeChatButtons = document.querySelectorAll('.write-chat-button');\n            writeChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    const panelChatId = button.getAttribute('data-panel-chat-id');\n                    const messageId = button.getAttribute('data-message-id');\n\n                    if (panelChatId) {\n                        vscode.postMessage({\n                            command: 'writeChatToStashedState',\n                            panelChatId: panelChatId\n                        });\n                    } else if (messageId) {\n                        vscode.postMessage({\n                            command: 'writeChatToStashedState',\n                            messageId: messageId\n                        });\n                    } else {\n                        console.warn('Write Chat button clicked without valid data.');\n                    }\n                });\n            });\n\n            // New Remove Chat Buttons for Added Changes\n            const removeChatButtons = document.querySelectorAll('.remove-chat-button');\n            removeChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    const panelChatId = button.getAttribute('data-panel-chat-id');\n                    const messageId = button.getAttribute('data-message-id');\n                    if (panelChatId) {\n                        vscode.postMessage({\n                            command: 'removePanelChatFromStashedState',\n                            panelChatId: panelChatId\n                        });\n                    } else if (messageId) {\n                        vscode.postMessage({\n                            command: 'removeMessageFromStashedState',\n                            messageId: messageId\n                        });\n                    } else {\n                        console.warn('Remove Chat button clicked without valid data.');\n                    }\n                });\n            });\n        }\n\n        /**\n         * Displays a custom confirmation modal before deleting a message or panel chat.\n         * @param {string} type - The type of deletion ('message' or 'panelChat').\n         * @param {string} id - The ID of the item to delete.\n         */\n        function showConfirmationModal(type, id) {\n            const modal = document.getElementById('confirmModal');\n            const modalMessage = modal.querySelector('p');\n            modalMessage.textContent = type === 'message' \n                ? 'Are you sure you want to delete this message?' \n                : 'Are you sure you want to delete this PanelChat?';\n\n            // Remove 'hidden' and add 'visible' to show the modal\n            modal.classList.remove('hidden');\n            modal.classList.add('visible');\n\n            // Handle \"Yes\" button click\n            document.getElementById('confirmYes').onclick = function() {\n                if (type === 'message') {\n                    //console.log('Sending deleteMessage command for ID: ' + id);\n                    vscode.postMessage({ command: 'deleteMessage', id: id });\n                } else if (type === 'panelChat') {\n                    //console.log('Sending deletePanelChat command for ID: ' + id);\n                    vscode.postMessage({ command: 'deletePanelChat', id: id });\n                }\n                // Hide the modal after action\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            };\n\n            // Handle \"No\" button click\n            document.getElementById('confirmNo').onclick = function() {\n                console.log('Deletion cancelled by user.');\n                // Hide the modal\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            };\n        }\n\n        // Close the modal when clicking outside of the modal content\n        window.onclick = function(event) {\n            const modal = document.getElementById('confirmModal');\n            if (event.target == modal) {\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            }\n        };\n\n\n        /**\n         * Attaches an event listener to the refresh button to update commit history.\n         */\n        document.getElementById('refreshButton').addEventListener('click', () => {\n            vscode.postMessage({ command: 'refresh' });\n        });\n\n        /**\n         * Attaches an event listener to the view dropdown to switch views.\n         */\n        document.getElementById('viewSelect').addEventListener('change', (event) => {\n            const select = event.target;\n            const selectedView = select.value;\n            vscode.postMessage({ command: 'switchView', view: selectedView });\n        });\n\n        let scrollPosition = 0;\n        let expandedCommits = new Set();\n        let expandedPanelChats = new Set(); // New Set to track expanded panel chats\n\n        function saveScrollPosition() {\n            scrollPosition = document.scrollingElement.scrollTop;\n        }\n\n        function restoreScrollPosition() {\n            document.scrollingElement.scrollTop = scrollPosition;\n        }\n\n        function saveExpandedCommits() {\n            expandedCommits.clear();\n            document.querySelectorAll('.commit-details').forEach((details, index) => {\n                if (details.style.display === 'block') {\n                    expandedCommits.add(index);\n                }\n            });\n        }\n\n        function restoreExpandedCommits() {\n            document.querySelectorAll('.commit-details').forEach((details, index) => {\n                if (expandedCommits.has(index)) {\n                    details.style.display = 'block';\n                }\n            });\n        }\n\n        /**\n         * Saves the expanded state of panel chats.\n         */\n        function saveExpandedPanelChats() {\n            expandedPanelChats.clear();\n            document.querySelectorAll('.panel-chat-details').forEach((details) => {\n                const parentHeader = details.previousElementSibling;\n                if (details.style.display === 'block' && parentHeader) {\n                    const panelChatId = parentHeader.getAttribute('data-panel-chat-id');\n                    if (panelChatId) {\n                        expandedPanelChats.add(panelChatId);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Restores the expanded state of panel chats.\n         */\n        function restoreExpandedPanelChats() {\n            document.querySelectorAll('.panel-chat-details').forEach((details) => {\n                const parentHeader = details.previousElementSibling;\n                if (parentHeader) {\n                    const panelChatId = parentHeader.getAttribute('data-panel-chat-id');\n                    if (panelChatId && expandedPanelChats.has(panelChatId)) {\n                        details.style.display = 'block';\n                    }\n                }\n            });\n        }\n\n        /**\n         * Handles incoming messages from the extension backend.\n         */\n        window.addEventListener('message', event => {\n            const message = event.data;\n            if (message.type === 'update') {\n                saveScrollPosition();\n                saveExpandedCommits();\n                saveExpandedPanelChats(); // Save expanded panel chats\n\n                const contentElement = document.getElementById('content');\n                contentElement.innerHTML = ''; // Clear existing content\n\n                if (message.commits && message.commits.length > 0) {\n                    message.commits.forEach(commit => {\n                        // Create commit container\n                        const commitDiv = document.createElement('div');\n                        commitDiv.className = 'commit';\n\n                        // Create commit header\n                        const commitHeader = document.createElement('div');\n                        commitHeader.className = 'commit-header';\n\n                        const isRegularCommit = commit.commitHash !== 'added' && commit.commitHash !== 'uncommitted';\n\n                        const commitMessage = isRegularCommit\n                        ? \\`\\${escapeHtml(commit.commitMessage)}\\`\n                        : \\`\\${escapeHtml(commit.commitMessage)}\\`;\n\n\n                        commitHeader.innerHTML = \\`\n                            <h3>\\${escapeHtml(commitMessage)}</h3>\n                            <span class=\"commit-date\">\\${new Date(commit.date).toLocaleString()}</span>\n                        \\`;\n\n                        commitDiv.appendChild(commitHeader);\n\n                        // Create commit details container\n                        const commitDetails = document.createElement('div');\n                        commitDetails.className = 'commit-details';\n\n                        // Populate panelChats\n                        if (commit.panelChats && commit.panelChats.length > 0) {\n                            commit.panelChats.forEach(panelChat => {\n                                // Create panelChat container\n                                const panelChatDiv = document.createElement('div');\n                                panelChatDiv.className = 'panel-chat';\n\n                                // PanelChat header with delete and append buttons\n                                const panelChatHeader = document.createElement('div');\n                                panelChatHeader.className = 'panel-chat-header';\n                                // When setting the data attribute for panelChat headers\n                                panelChatHeader.setAttribute('data-panel-chat-id', \\`\\${commit.commitHash}-\\${panelChat.id}\\`); // Add data attribute for identification\n                                panelChatHeader.innerHTML = \\`\n                                    Title: \\${escapeHtml(panelChat.customTitle)}\n                                    <button class=\"delete-panelchat-button\" data-id=\"\\${escapeHtml(panelChat.id)}\" title=\"Delete PanelChat\">🗑️</button>\n                                    <button \n                                        class=\"append-context-button\" \n                                        data-commit=\"\\${escapeHtml(commit.commitHash)}\" \n                                        data-id=\"\\${escapeHtml(panelChat.id)}\" \n                                        title=\"Append to context\"\n                                    >\n                                        📄\n                                    </button>\n                                \\`;\n\n                                // Determine if the commit is an uncommitted change\n                                const isUnadded = commit.commitHash === 'uncommitted';\n\n                                if (isUnadded) {\n                                    // Add Write Chat Button for Uncommitted Changes\n                                    panelChatHeader.innerHTML += \\`\n                                        <button \n                                            class=\"write-chat-button\" \n                                            data-panel-chat-id=\"\\${escapeHtml(panelChat.id)}\" \n                                            title=\"Write PanelChat to Stashed State\"\n                                        >\n                                            ➕\n                                        </button>\n                                    \\`;\n                                } else if (commit.commitHash === 'added') {\n                                    // Add Remove Chat Button for Added Changes\n                                    panelChatHeader.innerHTML += \\`\n                                        <button \n                                            class=\"remove-chat-button\" \n                                            data-panel-chat-id=\"\\${escapeHtml(panelChat.id)}\" \n                                            title=\"Remove PanelChat from Stashed State\"\n                                        >\n                                            ➖\n                                        </button>\n                                    \\`;\n                                }\n\n                                panelChatDiv.appendChild(panelChatHeader);\n\n                                // Create panel-chat-details container\n                                const panelChatDetails = document.createElement('div');\n                                panelChatDetails.className = 'panel-chat-details';\n\n                                // PanelChat info (customTitle, ai_editor, etc.)\n                                const panelChatInfo = document.createElement('div');\n                                panelChatInfo.className = 'panel-chat-info';\n                                panelChatInfo.innerHTML = \\`\n                                    <strong>AI Editor:</strong> \\${escapeHtml(panelChat.ai_editor)}<br>\n                                    <strong>Created On:</strong> \\${new Date(panelChat.created_on).toLocaleString()}<br>\n                                \\`;\n                                panelChatDetails.appendChild(panelChatInfo);\n\n                                // Messages in panelChat\n                                panelChat.messages.forEach(messageEntry => {\n                                    const messageContainer = document.createElement('div');\n                                    messageContainer.className = 'message-container';\n\n                                    // Delete button\n                                    const deleteBtn = document.createElement('button');\n                                    deleteBtn.className = 'delete-button';\n                                    deleteBtn.setAttribute('data-id', messageEntry.id);\n                                    deleteBtn.title = 'Delete Message';\n                                    deleteBtn.textContent = '×';\n                                    messageContainer.appendChild(deleteBtn);\n\n                                    // Determine if the commit is an uncommitted change\n                                    const isUnaddedMessage = commit.commitHash === 'uncommitted';\n\n                                    // Conditionally add Write or Remove Chat Buttons\n                                    if (isUnaddedMessage) {\n                                        // Add Write Chat Button for Messages\n                                        const writeBtn = document.createElement('button');\n                                        writeBtn.className = 'write-chat-button';\n                                        writeBtn.setAttribute('data-message-id', messageEntry.id); // Changed to 'data-message-id'\n                                        writeBtn.title = 'Write Message to Stashed State';\n                                        writeBtn.textContent = '➕';\n                                        messageContainer.appendChild(writeBtn);\n                                    } else if (commit.commitHash === 'added') {\n                                        // Add Remove Chat Button for Messages\n                                        const removeBtn = document.createElement('button');\n                                        removeBtn.className = 'remove-chat-button';\n                                        removeBtn.setAttribute('data-message-id', messageEntry.id); // Changed to 'data-message-id'\n                                        removeBtn.title = 'Remove Message from Stashed State';\n                                        removeBtn.textContent = '➖';\n                                        messageContainer.appendChild(removeBtn);\n                                    }\n\n                                    // Message Text\n                                    const messageDiv = document.createElement('div');\n                                    messageDiv.className = 'message';\n                                    messageDiv.innerHTML = escapeHtml(messageEntry.messageText);\n                                    messageContainer.appendChild(messageDiv);\n\n                                    // Response Text\n                                    const responseDiv = document.createElement('div');\n                                    responseDiv.className = 'response';\n                                    responseDiv.innerHTML = formatResponse(messageEntry.responseText);\n                                    messageContainer.appendChild(responseDiv);\n\n                                    // Additional Message Details\n                                    const messageDetails = document.createElement('div');\n                                    messageDetails.className = 'message-details';\n                                    messageDetails.style.fontSize = '0.8em';\n                                    messageDetails.style.color = 'var(--vscode-descriptionForeground)';\n                                    messageDetails.innerHTML = \\`\n                                        <strong>Model:</strong> \\${escapeHtml(messageEntry.model)}<br>\n                                        <strong>Timestamp:</strong> \\${new Date(messageEntry.timestamp).toLocaleString()}\n                                    \\`;\n                                    messageContainer.appendChild(messageDetails);\n\n                                    // Optionally, display context if needed\n                                    console.log('Message Entry Context:', messageEntry.context);\n                                    if (messageEntry.context && Array.isArray(messageEntry.context) && messageEntry.context.length > 0) {\n                                        const contextDiv = document.createElement('div');\n                                        contextDiv.className = 'context';\n                                        contextDiv.style.fontSize = '0.8em';\n                                        contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                                        const humanReadableContext = messageEntry.context\n                                        .filter(item => item && typeof item === 'object' && item.value && typeof item.value === 'object' && typeof item.value.human_readable === 'string')\n                                        .map(item => {\n                                            // Get the relative path\n                                            const fullPath = item.value.human_readable;\n                                            let relativePath = fullPath;\n                                            \n                                            if (workspaceFolderPath && fullPath.startsWith(workspaceFolderPath)) {\n                                                relativePath = fullPath.slice(workspaceFolderPath.length + 1);\n                                            }\n\n                                            const link = document.createElement('a');\n                                            link.href = '#';\n                                            link.textContent = escapeHtml(relativePath);\n                                            link.dataset.path = relativePath;\n                                            link.classList.add('context-link'); \n                                            return link.outerHTML;\n                                        })\n                                        .join(', ');\n                                        if (humanReadableContext) {\n                                            contextDiv.innerHTML = \\`<strong>Context:</strong> \\${humanReadableContext}\\`;\n                                            messageContainer.appendChild(contextDiv);\n                                        }\n                                    }\n\n                                    if (messageEntry.kv_store && 'file_paths' in messageEntry.kv_store) {\n                                        const contextDiv = document.createElement('div');\n                                        contextDiv.className = 'context';\n                                        contextDiv.style.fontSize = '0.8em';\n                                        contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                                        const associatedFilePaths = messageEntry.kv_store.file_paths\n                                        .map(filePath => {\n                                            let relativePath = filePath;\n                                            \n                                            if (workspaceFolderPath && filePath.startsWith(workspaceFolderPath)) {\n                                                relativePath = filePath.slice(workspaceFolderPath.length + 1);\n                                            }\n\n                                            const link = document.createElement('a');\n                                            link.href = '#';\n                                            link.textContent = escapeHtml(relativePath);\n                                            link.dataset.path = relativePath;\n                                            link.classList.add('context-link'); \n                                            return link.outerHTML;\n                                        })\n                                        .join(', ');\n                                        if (associatedFilePaths) {\n                                            contextDiv.innerHTML = \\`<strong>Associated Files:</strong> \\${associatedFilePaths}\\`;\n                                            messageContainer.appendChild(contextDiv);\n                                        }\n                                    }\n\n                                    panelChatDetails.appendChild(messageContainer);\n                                });\n\n                                commitDetails.appendChild(panelChatDetails);\n                                panelChatDiv.appendChild(panelChatDetails);\n\n                                commitDetails.appendChild(panelChatDiv);\n                            });\n                        } else {\n                            const noPanelChats = document.createElement('div');\n                            noPanelChats.className = 'no-messages';\n                            noPanelChats.textContent = 'No panelChats in this commit.';\n                            commitDetails.appendChild(noPanelChats);\n                        }\n\n                        commitDiv.appendChild(commitDetails);\n                        contentElement.appendChild(commitDiv);\n                    });\n\n                    // Attach event listeners for collapsible commits\n                    attachCommitToggleListeners();\n\n                    // Attach event listeners for collapsible panel chats\n                    attachPanelChatToggleListeners(); // New function call\n\n                    // Attach event listeners for delete, write, and remove buttons\n                    attachButtonListeners();\n\n                    attachLinkListeners();\n                } else {\n                    const noCommits = document.createElement('div');\n                    noCommits.className = 'no-commits';\n                    noCommits.textContent = 'No commits found.';\n                    contentElement.appendChild(noCommits);\n                }\n\n                // After updating the content\n                restoreExpandedCommits();\n                restoreExpandedPanelChats(); // Restore expanded panel chats\n                restoreScrollPosition();\n                Prism.highlightAll();\n            }\n        });\n\n        /**\n         * Notifies the extension that the Webview is ready.\n         */\n        // Notify the extension that the Webview is ready\n        vscode.postMessage({ command: 'webviewReady' });\n        //console.log('Webview is ready.');\n    </script>\n</body>\n</html>\n        `;\n    }\n\n}\n\n/**\n * Generates a random nonce for Content Security Policy.\n * @returns {string} - A random 32-character string.\n */\nfunction getNonce() {\n    let text = '';\n    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    for (let i = 0; i < 32; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n}\n",
          "diffs": [
            {
              "count": 227,
              "added": false,
              "removed": false,
              "value": "import * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport { CommitData, GitHistoryData, getGitHistory, getGitHistoryThatTouchesFile } from './panelgit';\nimport { PanelChat } from './types';\nimport { readStashedState, writeStashedState, removeMessageFromStashedState, removePanelChatFromStashedState, writeChatToStashedState } from './stashedState';\nimport { panelChatsToMarkdown } from './markdown'; // Added import\nimport { STASHED_GAIT_STATE_FILE_NAME } from './constants';\nimport posthog from 'posthog-js';\nimport { identifyUser } from './identify_user';\n\nexport class PanelViewProvider implements vscode.WebviewViewProvider {\n    public static readonly viewType = 'gait-copilot.panelView';\n\n    private _view?: vscode.WebviewView;\n    private _commits: CommitData[] = [];\n    private _isFilteredView: boolean = false; // New state to track view type\n\n    /**\n     * Loads commits and integrates uncommitted changes into the commits array.\n     * Supports both default and filtered views based on _isFilteredView.\n     */\n    private async loadCommitsAndChats(additionalFilePath?: string) {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n            //vscode.window.showErrorMessage('No workspace folder found.');\n            return;\n        }\n        let context = this._context;\n\n        const repoPath = workspaceFolder.uri.fsPath;\n        const filePath = `.gait/${STASHED_GAIT_STATE_FILE_NAME}`; // Replace with your actual file path relative to repo\n\n        try {\n            if (this._isFilteredView && additionalFilePath) {\n                const gitHistory: GitHistoryData = await getGitHistoryThatTouchesFile(this._context, repoPath, filePath, additionalFilePath);\n\n                // Map CommitData from getGitHistoryThatTouchesFile to the class's commit structure\n                this._commits = gitHistory.commits.map(commit => ({\n                    commitHash: commit.commitHash,\n                    commitMessage: commit.commitMessage,\n                    author: commit.author,\n                    date: new Date(commit.date),\n                    panelChats: commit.panelChats,\n                    inlineChats: commit.inlineChats\n                })).sort((a, b) => b.date.getTime() - a.date.getTime());\n\n                if (gitHistory.added) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'added',\n                        author: 'You',\n                        commitMessage: 'Added Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.added.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.added.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n                else{\n                    console.log(\"No added changes\");\n                }\n\n                // Handle uncommitted changes by appending them to the commits array\n                if (gitHistory.uncommitted) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'uncommitted',\n                        author: 'You',\n                        commitMessage: 'Unadded Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.uncommitted.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.uncommitted.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n            } else {\n                const gitHistory: GitHistoryData = await getGitHistory(this._context, repoPath, filePath);\n\n                // Map CommitData from getGitHistory to the class's commit structure\n                this._commits = gitHistory.commits.map(commit => ({\n                    commitHash: commit.commitHash,\n                    commitMessage: commit.commitMessage,\n                    author: commit.author,\n                    date: new Date(commit.date),\n                    panelChats: commit.panelChats,\n                    inlineChats: commit.inlineChats\n                })).sort((a, b) => b.date.getTime() - a.date.getTime());\n\n                if (gitHistory.added) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'added',\n                        author: 'You',\n                        commitMessage: 'Added Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.added.panelChats, // Updated to use panelChats\n                        inlineChats: gitHistory.added.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n\n                // Handle uncommitted changes by appending them to the commits array\n                if (gitHistory.uncommitted) {\n                    const uncommittedCommit: CommitData = {\n                        commitHash: 'uncommitted',\n                        author: 'You',\n                        commitMessage: 'Unadded Changes',\n                        date: new Date(), // Current date and time\n                        panelChats: gitHistory.uncommitted.panelChats,\n                        inlineChats: gitHistory.uncommitted.inlineChats\n                    };\n                    this._commits.unshift(uncommittedCommit); // Add to the beginning for visibility\n                }\n            }\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Error loading git history: ${error.message}`);\n            this._commits = [];\n        }\n    }\n\n    /**\n     * Updates the webview content by loading commits and integrating uncommitted changes.\n     */\n    public async updateContent() {\n\n        if (this._isFilteredView) {\n            const editor = vscode.window.activeTextEditor;\n            if (editor) {\n                const document = editor.document;\n                const filePath = vscode.workspace.asRelativePath(document.uri.fsPath);\n                await this.loadCommitsAndChats(filePath);\n            }\n        } else {\n            await this.loadCommitsAndChats();\n        }\n        if (this._view) {\n            this._view.webview.postMessage({\n                type: 'update',\n                commits: this._commits,\n            });\n        }\n    }\n\n    constructor(private readonly _context: vscode.ExtensionContext) {\n        // Initialize by loading commits and chats\n        this.loadCommitsAndChats().catch(error => {\n            vscode.window.showErrorMessage(`Initialization error: ${(error as Error).message}`);\n        });\n    }\n\n    private async handleDeletePanelChat(panelChatId: string) {\n        const stashedState = readStashedState(this._context);\n        stashedState.deletedChats.deletedPanelChatIDs.push(panelChatId);\n        writeStashedState(this._context, stashedState);\n    }\n\n    private async handleRemovePanelChatFromStashedState(panelChatId: string) {\n        console.log(`Removing panelChat with ID ${panelChatId} from stashed state.`);\n        removePanelChatFromStashedState(this._context, panelChatId);\n    }\n\n    private async handleRemoveMessageFromStashedState(messageId: string) {\n        console.log(`Removing message with ID ${messageId} from stashed state.`);\n        removeMessageFromStashedState(this._context, messageId);\n    }\n\n    private async handleWriteChatToStashedState(panelChatId?: string, messageId?: string) {\n        if ((panelChatId && messageId) || (!panelChatId && !messageId)) {\n            vscode.window.showErrorMessage('Invalid parameters: Provide either panelChatId or messageId, but not both.');\n            if (panelChatId && messageId) {\n                vscode.window.showErrorMessage('Both panelChatId and messageId provided. Please provide only one.');\n            }\n            else {\n                vscode.window.showErrorMessage('No panelChatId or messageId provided. Please provide one.');\n            }\n            return;\n        }\n\n        try {\n            if (panelChatId) {\n                // Find the PanelChat with the given panelChatId\n                    const panelChat = this._commits[0].panelChats.find(pc => pc.id === panelChatId);\n                    if (panelChat) {\n                        // Write the entire PanelChat to stashed state\n                        await writeChatToStashedState(this._context, panelChat);\n                        vscode.window.showInformationMessage(`PanelChat with ID ${panelChatId} has been stashed.`);\n                        return;\n                    }\n                \n                vscode.window.showErrorMessage(`PanelChat with ID ${panelChatId} not found.`);\n            } else if (messageId) {\n                // Find the MessageEntry with the given messageId\n                    for (const panelChat of this._commits[0].panelChats) {\n                        const message = panelChat.messages.find(msg => msg.id === messageId);\n                        if (message) {\n                            // Construct a new PanelChat containing only this message\n                            const newPanelChat: PanelChat = {\n                                ai_editor: panelChat.ai_editor,\n                                id: panelChat.id,\n                                customTitle: `Stashed Message ${message.id}`,\n                                parent_id: null,\n                                created_on: new Date().toISOString(),\n                                messages: [message],\n                                kv_store: {}\n                            };\n                            // Write the new PanelChat to stashed state\n                            await writeChatToStashedState(this._context, newPanelChat);\n                            vscode.window.showInformationMessage(`Message with ID ${messageId} has been stashed.`);\n                            return;\n                        }\n                    \n                }\n                vscode.window.showErrorMessage(`Message with ID ${messageId} not found.`);\n            }\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to write chat to stashed state: ${error.message}`);\n            console.error(`Error in handleWriteChatToStashedState: ${error.stack}`);\n        }\n    }\n\n    public resolveWebviewView(\n        webviewView: vscode.WebviewView,\n        context: vscode.WebviewViewResolveContext,\n        _token: vscode.CancellationToken\n    ) {\n        identifyUser(this._context);\n        posthog.capture('$pageview');\n        this._view = webviewView;\n"
            },
            {
              "count": 9,
              "added": true,
              "removed": false,
              "value": "        // Add analytics for the number of inlineChats and panelChats saved\n        const stashedState = readStashedState(this._context);\n        const panelChatsCount = stashedState.panelChats.length;\n        const inlineChatsCount = stashedState.inlineChats.length;\n        \n        posthog.capture('panel_view_opened', {\n            panelChatsCount: panelChatsCount,\n            inlineChatsCount: inlineChatsCount\n        });\n"
            },
            {
              "count": 1150,
              "added": false,
              "removed": false,
              "value": "\n        webviewView.webview.options = {\n            enableScripts: true,\n        };\n\n        webviewView.webview.html = this.getHtmlForWebview(webviewView.webview);\n\n        webviewView.webview.onDidReceiveMessage(message => {\n            switch (message.command) {\n                case 'webviewReady':\n                    this.updateContent();\n                    break;\n                case 'deleteMessage':\n                    posthog.capture('delete_message');\n                    this.handleDeleteMessage(message.id);\n                    this.updateContent();\n                    break;\n                case 'deletePanelChat':\n                    posthog.capture('delete_panelchat');\n                    this.handleDeletePanelChat(message.id);\n                    this.updateContent();\n                    break;\n                case 'refresh':\n                    this.updateContent();\n                    break;\n                case 'switchView':\n                    this.handleSwitchView(message.view);\n                    break;\n                case 'appendContext': // New case for appending context\n                    this.handleAppendContext(message.commitHash, message.panelChatId);\n                    break;\n                case 'writeChatToStashedState': // New case for writing chat to stashed state\n                    this.handleWriteChatToStashedState(message.panelChatId, message.messageId);\n                    posthog.capture('manual_stage');\n                    this.updateContent();\n                    break;                \n                case 'removePanelChatFromStashedState': // New case for removing panelChat from stashed state\n                    this.handleRemovePanelChatFromStashedState(message.panelChatId);\n                    posthog.capture('manual_unstage');\n                    this.updateContent();\n                    break;\n                case 'removeMessageFromStashedState': // New case for removing message from stashed state\n                    this.handleRemoveMessageFromStashedState(message.messageId);\n                    this.updateContent();\n                    break;\n                case 'openFile':\n                    this.handleOpenFile(message.path);\n                    break;\n                default:\n                    break;\n            }\n        });\n\n        webviewView.onDidChangeVisibility(() => {\n            if (webviewView.visible) {\n                this.updateContent();\n            }\n        });\n    }\n\n    /**\n     * Handles switching between default and filtered views based on user selection.\n     * @param view - The selected view type.\n     */\n    private async handleSwitchView(view: string) {\n        if (view === 'filtered') {\n            this._isFilteredView = true;\n            //await this.updateContent();\n        } else {\n            // Default view\n            this._isFilteredView = false;\n        }\n        await this.updateContent();\n    }\n\n    /**\n     * Handles the deletion of a message by its ID.\n     * @param messageId - The ID of the message to delete.\n     */\n    private async handleDeleteMessage(messageId: string) {\n        const stashedState = readStashedState(this._context);\n        stashedState.deletedChats.deletedMessageIDs.push(messageId);\n        writeStashedState(this._context, stashedState);\n    }\n\n    /**\n     * Handles appending panelChat messages to gaitContext.md\n     * @param commitHash - The hash of the commit containing the panelChat.\n     * @param panelChatId - The ID of the panelChat to append.\n     */\n    private async handleAppendContext(commitHash: string, panelChatId: string) {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n            //vscode.window.showErrorMessage('No workspace folder found.');\n            return;\n        }\n\n        const repoPath = workspaceFolder.uri.fsPath;\n        const filePath = path.join(repoPath, 'gait_context.md');\n\n        try {\n            // Ensure the file exists; if not, create it with a header\n            if (!fs.existsSync(filePath)) {\n                fs.writeFileSync(filePath, '# Gait Context\\n\\n', 'utf-8');\n            }\n\n            // Find the specific commit\n            const targetCommit = this._commits.find(commit => commit.commitHash === commitHash);\n            if (!targetCommit) {\n                vscode.window.showErrorMessage(`Commit with hash ${commitHash} not found.`);\n                return;\n            }\n\n            // Find the specific panelChat within the commit\n            const targetPanelChat = targetCommit.panelChats.find(pc => pc.id === panelChatId);\n            if (!targetPanelChat) {\n                vscode.window.showErrorMessage(`PanelChat with ID ${panelChatId} not found in commit ${commitHash}.`);\n                return;\n            }\n\n            // Convert the panelChat to Markdown\n            const markdownContent = panelChatsToMarkdown([{ commit: targetCommit, panelChat: targetPanelChat }]);\n\n            // Append the markdown content to gaitContext.md\n            fs.appendFileSync(filePath, markdownContent + '\\n\\n', 'utf-8');\n            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(filePath), { viewColumn: vscode.ViewColumn.Beside });\n            await vscode.commands.executeCommand('aichat.newchataction');\n\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to append context: ${error.message}`);\n            console.error(`Error appending context: ${error.stack}`);\n        }\n    }\n\n    /**\n     * Handles opening a file in the editor.\n     * @param filePath - The path of the file to open.\n     */\n    private async handleOpenFile(filePath: string) {\n        console.log(`Opening file: ${filePath}`);\n        try {\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n            if (!workspaceFolder) {\n                vscode.window.showErrorMessage('No workspace folder found.');\n                return;\n            }\n\n            const fullPath = vscode.Uri.file(path.join(workspaceFolder.uri.fsPath, filePath));\n            const document = await vscode.workspace.openTextDocument(fullPath);\n            await vscode.window.showTextDocument(document);\n        } catch (error: any) {\n            vscode.window.showErrorMessage(`Failed to open file: ${error.message}`);\n        }\n    }\n\n    /**\n     * Generates the HTML content for the webview, including a dropdown for view selection.\n     * @param webview - The Webview instance.\n     * @returns A string containing the HTML.\n     */\n    private getHtmlForWebview(webview: vscode.Webview): string {\n        const nonce = getNonce();\n        const prismCssPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'prism.css');\n        const prismJsPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'prism.js');\n        const markedJsPath = vscode.Uri.joinPath(this._context.extensionUri, 'media', 'marked.js'); // Path to Marked.js\n        const prismCssUri = webview.asWebviewUri(prismCssPath);\n        const prismJsUri = webview.asWebviewUri(prismJsPath);\n        const markedJsUri = webview.asWebviewUri(markedJsPath); // URI for Marked.js\n        const workspaceFolderPath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\n\n        return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <script>\n    !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(\".\");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement(\"script\")).type=\"text/javascript\",p.async=!0,p.src=s.api_host.replace(\".i.posthog.com\",\"-assets.i.posthog.com\")+\"/static/array.js\",(r=t.getElementsByTagName(\"script\")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a=\"posthog\",u.people=u.people||[],u.toString=function(t){var e=\"posthog\";return\"posthog\"!==a&&(e+=\".\"+a),t||(e+=\" (stub)\"),e},u.people.toString=function(){return u.toString(1)+\".people (stub)\"},o=\"capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys getNextSurveyStep onSessionId\".split(\" \"),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);\n    posthog.init('phc_vosMtvFFxCN470e8uHGDYCD6YuuSRSoFoZeLuciujry',{api_host:'https://us.i.posthog.com',})\n    </script>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Git Commit History</title>\n    \n <!-- Content Security Policy -->\n    <meta http-equiv=\"Content-Security-Policy\" content=\"\n        default-src 'none';\n        style-src 'nonce-${nonce}' ${webview.cspSource};\n        script-src 'nonce-${nonce}' ${webview.cspSource};\n        connect-src 'self';\n        img-src 'self';\n        font-src 'self';\n    \">\n    \n    <!-- Prism.js CSS -->\n    <link href=\"${prismCssUri}\" rel=\"stylesheet\" />\n    <!-- Marked.js -->\n    <script src=\"${markedJsUri}\" nonce=\"${nonce}\"></script>\n\n    <style nonce=\"${nonce}\">\n        body {\n            font-family: var(--vscode-font-family);\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n            padding: 0;\n            margin: 0;\n            overflow: auto;\n        }\n        .container {\n            max-width: 1000px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        .header {\n            background-color: var(--vscode-titleBar-activeBackground);\n            color: var(--vscode-titleBar-activeForeground);\n            padding: 15px;\n            border-radius: 5px 5px 0 0;\n            margin-bottom: 20px;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n        }\n        .header h2 {\n            margin: 0;\n            font-size: 1.5em;\n        }\n        .commit {\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            padding: 15px;\n            margin-bottom: 15px;\n            background-color: var(--vscode-editor-inactiveSelectionBackground);\n        }\n        .commit-date {\n            color: var(--vscode-descriptionForeground);\n            font-size: 0.9em;\n        }\n        .commit-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            cursor: pointer;\n        }\n        .commit-header:hover {\n            background-color: var(--vscode-editor-selectionBackground);\n        }\n        .commit-header h3 {\n            margin: 0;\n            font-size: 1.2em;\n        }\n        .commit-details {\n            display: none;\n            margin-top: 10px;\n        }\n        .panel-chat {\n            margin-bottom: 15px;\n            padding: 10px;\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            background-color: var(--vscode-editor-background);\n        }\n        .panel-chat-header {\n            font-weight: bold;\n            margin-bottom: 5px;\n            display: flex;\n            align-items: center;\n            cursor: pointer; /* Make it clickable */\n        }\n        .panel-chat-header:hover {\n            background-color: var(--vscode-editor-selectionBackground);\n        }\n        .panel-chat-info {\n            font-size: 0.9em;\n            color: var(--vscode-descriptionForeground);\n            margin-bottom: 10px;\n        }\n        .panel-chat-details {\n            display: none; /* Hidden by default */\n            margin-top: 10px;\n        }\n        .message-container {\n            margin-bottom: 15px;\n            position: relative;\n            border: 1px solid var(--vscode-editorWidget-border);\n            border-radius: 5px;\n            padding: 10px;\n            background-color: var(--vscode-editor-background);\n        }\n        .delete-button {\n            position: absolute;\n            top: 10px;\n            right: 10px;\n            background: transparent;\n            border: none;\n            color: red;\n            font-weight: bold;\n            cursor: pointer;\n            font-size: 16px;\n        }\n        .delete-panelchat-button {\n            background: transparent;\n            border: none;\n            color: red;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .delete-panelchat-button:hover {\n            color: darkred;\n        }\n        .append-context-button {\n            background: transparent;\n            border: none;\n            color: blue;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .append-context-button:hover {\n            color: darkblue;\n        }\n        .write-chat-button {\n            background: transparent;\n            border: none;\n            color: green;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .write-chat-button:hover {\n            color: darkgreen;\n        }\n        .remove-chat-button {\n            background: transparent;\n            border: none;\n            color: orange;\n            font-weight: bold;\n            cursor: pointer;\n            margin-left: 10px;\n            font-size: 16px;\n        }\n        .remove-chat-button:hover {\n            color: darkorange;\n        }\n        .message, .response {\n            padding: 10px;\n            border-radius: 5px;\n            margin-bottom: 5px;\n        }\n        .message {\n            background-color: var(--vscode-editor-selectionBackground);\n            word-wrap: break-word;\n        }\n        .response {\n            background-color: var(--vscode-editorWidget-background);\n            word-wrap: break-word;\n        }\n        pre {\n            background-color: var(--vscode-textCodeBlock-background);\n            padding: 8px;\n            border-radius: 3px;\n            font-family: var(--vscode-editor-font-family);\n            overflow-x: auto;\n        }\n        code {\n            font-family: var(--vscode-editor-font-family);\n            font-size: 0.9em;\n        }\n        .no-commits, .no-messages {\n            text-align: center;\n            color: var(--vscode-editorError-foreground);\n            font-style: italic;\n            margin-top: 20px;\n        }\n\n        /* Dropdown Styles */\n        .dropdown-container {\n            margin-bottom: 20px;\n            display: flex;\n            justify-content: flex-end;\n            align-items: center;\n        }\n\n        .dropdown-container label {\n            margin-right: 10px;\n            font-weight: bold;\n        }\n\n        .dropdown-container select {\n            padding: 5px;\n            border-radius: 4px;\n            border: 1px solid var(--vscode-editorWidget-border);\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n        }\n\n        /* Modal Styles */\n        .modal {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            z-index: 1000; /* Ensure it's on top */\n        }\n\n        .modal-content {\n            background-color: var(--vscode-editor-background);\n            color: var(--vscode-editor-foreground);\n            padding: 20px;\n            border-radius: 8px;\n            width: 300px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n\n        .modal-buttons {\n            display: flex;\n            justify-content: flex-end;\n            margin-top: 20px;\n        }\n\n        .modal-buttons button {\n            margin-left: 10px;\n            padding: 5px 10px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n\n        #confirmYes {\n            background-color: var(--vscode-button-background);\n            color: var(--vscode-button-foreground);\n        }\n\n        #confirmNo {\n            background-color: var(--vscode-button-secondaryBackground);\n            color: var(--vscode-button-secondaryForeground);\n        }\n\n        .hidden {\n            display: none;\n        }\n\n        .visible {\n            display: flex; /* or block, depending on your layout needs */\n        }\n\n\n        /* Override Prism.js styles if necessary */\n        /* Example: Adjusting code block background */\n        pre[class*=\"language-\"] {\n            background: var(--vscode-textCodeBlock-background) !important;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h2>Git Commit History</h2>\n            <button id=\"refreshButton\" title=\"Refresh Commit History\">🔄</button>\n        </div>\n\n        <!-- Dropdown for selecting view -->\n        <div class=\"dropdown-container\">\n            <label for=\"viewSelect\">View:</label>\n            <select id=\"viewSelect\">\n                <option value=\"default\">All Commits</option>\n                <option value=\"filtered\">Commits Touching Specific File</option>\n            </select>\n        </div>\n\n        <div id=\"content\">\n            <div class=\"no-commits\">Loading commit history...</div>\n        </div>\n    </div>\n\n    <!-- Confirmation Modal -->\n    <div id=\"confirmModal\" class=\"modal hidden\">\n        <div class=\"modal-content\">\n            <p>Are you sure you want to delete this item?</p>\n            <div class=\"modal-buttons\">\n                <button id=\"confirmYes\">Yes</button>\n                <button id=\"confirmNo\">No</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Prism.js JS -->\n    <script src=\"${prismJsUri}\" nonce=\"${nonce}\"> </script>\n\n    <script nonce=\"${nonce}\">\n\n        setInterval(() => {\n            vscode.postMessage({ command: 'refresh' });\n        }, 3000);\n\n        const vscode = acquireVsCodeApi();\n        const workspaceFolderPath = '${workspaceFolderPath}';\n\n        /**\n         * Escapes HTML characters to prevent XSS attacks.\n         * @param {string} text - The text to escape.\n         * @returns {string} - The escaped text.\n         */\n        function escapeHtml(text) {\n            const map = {\n                '&': '&amp;',\n                '<': '&lt;',\n                '>': '&gt;',\n                '\"': '&quot;',\n                \"'\": '&#039;'\n            };\n            return text.replace(/[&<>\"']/g, function(m) { return map[m]; });\n        }\n\n        function formatResponse(responseText) {\n            if (typeof responseText !== 'string') {\n                console.warn('formatResponse received non-string responseText:', responseText);\n                return '<em>Invalid response text.</em>';\n            }\n\n            // Enhanced regex to handle optional newline after language specifier\n            const codeBlockRegex = /\\`\\`\\`(\\\\w+)?\\\\n?([\\\\s\\\\S]+?)\\`\\`\\`/g;\n            let formattedText = '';\n            let lastIndex = 0;\n            let match;\n            let matchFound = false;\n\n            console.warn('Response text:', responseText); // Debugging log\n\n            while ((match = codeBlockRegex.exec(responseText)) !== null) {\n                matchFound = true;\n                const index = match.index;\n                console.warn('Matched code block:', match[0]); // Debugging log\n\n                // Escape and append text before the code block\n                formattedText += escapeHtml(responseText.slice(lastIndex, index));\n\n                const language = match[1] ? match[1].trim().replace(/\\\\n+$/, '') : '';\n                const code = match[2] ? escapeHtml(match[2].trim()) : '';\n\n                console.warn('Language', JSON.stringify(language));// Debugging log\n                console.warn('Code', JSON.stringify(code)); // Debugging log\n\n                // Append the formatted code block\n                formattedText += \\`<pre><code class=\"language-\\${language}\">\\${code}</code></pre>\\`;\n\n                lastIndex = index + match[0].length;\n            }\n\n            if (!matchFound) {\n                console.warn('No code blocks found in responseText.');\n            }\n\n            // Escape and append the remaining text after the last code block\n            formattedText += marked.parse(escapeHtml(responseText.slice(lastIndex)));\n            return formattedText;\n        }\n\n\n        /**\n         * Attaches click listeners to commit headers to toggle visibility of commit details.\n         */\n        function attachCommitToggleListeners() {\n            const commitHeaders = document.querySelectorAll('.commit-header');\n            commitHeaders.forEach(header => {\n                header.addEventListener('click', () => {\n                    const details = header.nextElementSibling;\n                    if (details) {\n                        if (details.style.display === 'block') {\n                            details.style.display = 'none';\n                        } else {\n                            details.style.display = 'block';\n                            const codeBlocks = details.querySelectorAll('pre code');\n                            console.log('Found code blocks:', codeBlocks);\n                            codeBlocks.forEach((block) => {\n                                Prism.highlightElement(block);\n                            });\n                        }\n                    }\n                });\n            });\n        }\n\n        /**\n         * Attaches click listeners to panel chat headers to toggle visibility of panel chat details.\n         */\n        function attachPanelChatToggleListeners() {\n            const panelChatHeaders = document.querySelectorAll('.panel-chat-header');\n            panelChatHeaders.forEach(header => {\n                header.addEventListener('click', () => {\n                    const details = header.nextElementSibling;\n                    if (details) {\n                        if (details.style.display === 'block') {\n                            details.style.display = 'none';\n                        } else {\n                            details.style.display = 'block';\n                            const codeBlocks = details.querySelectorAll('pre code');\n                            console.log('Found code blocks in panel chat:', codeBlocks);\n                            codeBlocks.forEach((block) => {\n                                Prism.highlightElement(block);\n                            });\n                        }\n                    }\n                });\n            });\n        }\n\n        function attachLinkListeners() {\n            const contentElement = document.getElementById('content');\n            contentElement.addEventListener('click', (event) => {\n                const target = event.target;\n                if (target && target.matches('a.context-link')) {\n                    event.preventDefault();\n                    const path = target.dataset.path;\n                    if (path) {\n                        console.log('Context link clicked:', path);\n                        vscode.postMessage({ command: 'openFile', path: path });\n                    } else {\n                        console.warn('Clicked link does not have a data-path attribute.');\n                    }\n                }\n            });\n        }\n\n        /**\n         * Attaches click listeners to delete, write, and remove buttons to handle respective actions.\n         */\n        function attachButtonListeners() {\n            // Existing Delete Message Buttons\n            const deleteMessageButtons = document.querySelectorAll('.delete-button');\n            deleteMessageButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const messageId = button.getAttribute('data-id');\n                    if (messageId) {\n                        showConfirmationModal('message', messageId);\n                    } else {\n                        console.warn('Delete button clicked without a valid message ID.');\n                    }\n                });\n            });\n\n            // Existing Delete PanelChat Buttons\n            const deletePanelChatButtons = document.querySelectorAll('.delete-panelchat-button');\n            deletePanelChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const panelChatId = button.getAttribute('data-id');\n                    if (panelChatId) {\n                        showConfirmationModal('panelChat', panelChatId);\n                    } else {\n                        console.warn('Delete PanelChat button clicked without a valid PanelChat ID.');\n                    }\n                });\n            });\n\n            // New Append to gaitContext.md Buttons\n            const appendContextButtons = document.querySelectorAll('.append-context-button');\n            appendContextButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation(); // Prevent triggering the commit toggle\n                    const commitHash = button.getAttribute('data-commit');\n                    const panelChatId = button.getAttribute('data-id');\n                    if (commitHash && panelChatId) {\n                        vscode.postMessage({ \n                            command: 'appendContext', \n                            commitHash: commitHash, \n                            panelChatId: panelChatId \n                        });\n                    } else {\n                        console.warn('Append Context button clicked without valid commitHash or PanelChat ID.');\n                    }\n                });\n            });\n\n            // New Write Chat Buttons for Unadded Changes\n            const writeChatButtons = document.querySelectorAll('.write-chat-button');\n            writeChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    const panelChatId = button.getAttribute('data-panel-chat-id');\n                    const messageId = button.getAttribute('data-message-id');\n\n                    if (panelChatId) {\n                        vscode.postMessage({\n                            command: 'writeChatToStashedState',\n                            panelChatId: panelChatId\n                        });\n                    } else if (messageId) {\n                        vscode.postMessage({\n                            command: 'writeChatToStashedState',\n                            messageId: messageId\n                        });\n                    } else {\n                        console.warn('Write Chat button clicked without valid data.');\n                    }\n                });\n            });\n\n            // New Remove Chat Buttons for Added Changes\n            const removeChatButtons = document.querySelectorAll('.remove-chat-button');\n            removeChatButtons.forEach(button => {\n                button.addEventListener('click', (event) => {\n                    event.stopPropagation();\n                    const panelChatId = button.getAttribute('data-panel-chat-id');\n                    const messageId = button.getAttribute('data-message-id');\n                    if (panelChatId) {\n                        vscode.postMessage({\n                            command: 'removePanelChatFromStashedState',\n                            panelChatId: panelChatId\n                        });\n                    } else if (messageId) {\n                        vscode.postMessage({\n                            command: 'removeMessageFromStashedState',\n                            messageId: messageId\n                        });\n                    } else {\n                        console.warn('Remove Chat button clicked without valid data.');\n                    }\n                });\n            });\n        }\n\n        /**\n         * Displays a custom confirmation modal before deleting a message or panel chat.\n         * @param {string} type - The type of deletion ('message' or 'panelChat').\n         * @param {string} id - The ID of the item to delete.\n         */\n        function showConfirmationModal(type, id) {\n            const modal = document.getElementById('confirmModal');\n            const modalMessage = modal.querySelector('p');\n            modalMessage.textContent = type === 'message' \n                ? 'Are you sure you want to delete this message?' \n                : 'Are you sure you want to delete this PanelChat?';\n\n            // Remove 'hidden' and add 'visible' to show the modal\n            modal.classList.remove('hidden');\n            modal.classList.add('visible');\n\n            // Handle \"Yes\" button click\n            document.getElementById('confirmYes').onclick = function() {\n                if (type === 'message') {\n                    //console.log('Sending deleteMessage command for ID: ' + id);\n                    vscode.postMessage({ command: 'deleteMessage', id: id });\n                } else if (type === 'panelChat') {\n                    //console.log('Sending deletePanelChat command for ID: ' + id);\n                    vscode.postMessage({ command: 'deletePanelChat', id: id });\n                }\n                // Hide the modal after action\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            };\n\n            // Handle \"No\" button click\n            document.getElementById('confirmNo').onclick = function() {\n                console.log('Deletion cancelled by user.');\n                // Hide the modal\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            };\n        }\n\n        // Close the modal when clicking outside of the modal content\n        window.onclick = function(event) {\n            const modal = document.getElementById('confirmModal');\n            if (event.target == modal) {\n                modal.classList.remove('visible');\n                modal.classList.add('hidden');\n            }\n        };\n\n\n        /**\n         * Attaches an event listener to the refresh button to update commit history.\n         */\n        document.getElementById('refreshButton').addEventListener('click', () => {\n            vscode.postMessage({ command: 'refresh' });\n        });\n\n        /**\n         * Attaches an event listener to the view dropdown to switch views.\n         */\n        document.getElementById('viewSelect').addEventListener('change', (event) => {\n            const select = event.target;\n            const selectedView = select.value;\n            vscode.postMessage({ command: 'switchView', view: selectedView });\n        });\n\n        let scrollPosition = 0;\n        let expandedCommits = new Set();\n        let expandedPanelChats = new Set(); // New Set to track expanded panel chats\n\n        function saveScrollPosition() {\n            scrollPosition = document.scrollingElement.scrollTop;\n        }\n\n        function restoreScrollPosition() {\n            document.scrollingElement.scrollTop = scrollPosition;\n        }\n\n        function saveExpandedCommits() {\n            expandedCommits.clear();\n            document.querySelectorAll('.commit-details').forEach((details, index) => {\n                if (details.style.display === 'block') {\n                    expandedCommits.add(index);\n                }\n            });\n        }\n\n        function restoreExpandedCommits() {\n            document.querySelectorAll('.commit-details').forEach((details, index) => {\n                if (expandedCommits.has(index)) {\n                    details.style.display = 'block';\n                }\n            });\n        }\n\n        /**\n         * Saves the expanded state of panel chats.\n         */\n        function saveExpandedPanelChats() {\n            expandedPanelChats.clear();\n            document.querySelectorAll('.panel-chat-details').forEach((details) => {\n                const parentHeader = details.previousElementSibling;\n                if (details.style.display === 'block' && parentHeader) {\n                    const panelChatId = parentHeader.getAttribute('data-panel-chat-id');\n                    if (panelChatId) {\n                        expandedPanelChats.add(panelChatId);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Restores the expanded state of panel chats.\n         */\n        function restoreExpandedPanelChats() {\n            document.querySelectorAll('.panel-chat-details').forEach((details) => {\n                const parentHeader = details.previousElementSibling;\n                if (parentHeader) {\n                    const panelChatId = parentHeader.getAttribute('data-panel-chat-id');\n                    if (panelChatId && expandedPanelChats.has(panelChatId)) {\n                        details.style.display = 'block';\n                    }\n                }\n            });\n        }\n\n        /**\n         * Handles incoming messages from the extension backend.\n         */\n        window.addEventListener('message', event => {\n            const message = event.data;\n            if (message.type === 'update') {\n                saveScrollPosition();\n                saveExpandedCommits();\n                saveExpandedPanelChats(); // Save expanded panel chats\n\n                const contentElement = document.getElementById('content');\n                contentElement.innerHTML = ''; // Clear existing content\n\n                if (message.commits && message.commits.length > 0) {\n                    message.commits.forEach(commit => {\n                        // Create commit container\n                        const commitDiv = document.createElement('div');\n                        commitDiv.className = 'commit';\n\n                        // Create commit header\n                        const commitHeader = document.createElement('div');\n                        commitHeader.className = 'commit-header';\n\n                        const isRegularCommit = commit.commitHash !== 'added' && commit.commitHash !== 'uncommitted';\n\n                        const commitMessage = isRegularCommit\n                        ? \\`\\${escapeHtml(commit.commitMessage)}\\`\n                        : \\`\\${escapeHtml(commit.commitMessage)}\\`;\n\n\n                        commitHeader.innerHTML = \\`\n                            <h3>\\${escapeHtml(commitMessage)}</h3>\n                            <span class=\"commit-date\">\\${new Date(commit.date).toLocaleString()}</span>\n                        \\`;\n\n                        commitDiv.appendChild(commitHeader);\n\n                        // Create commit details container\n                        const commitDetails = document.createElement('div');\n                        commitDetails.className = 'commit-details';\n\n                        // Populate panelChats\n                        if (commit.panelChats && commit.panelChats.length > 0) {\n                            commit.panelChats.forEach(panelChat => {\n                                // Create panelChat container\n                                const panelChatDiv = document.createElement('div');\n                                panelChatDiv.className = 'panel-chat';\n\n                                // PanelChat header with delete and append buttons\n                                const panelChatHeader = document.createElement('div');\n                                panelChatHeader.className = 'panel-chat-header';\n                                // When setting the data attribute for panelChat headers\n                                panelChatHeader.setAttribute('data-panel-chat-id', \\`\\${commit.commitHash}-\\${panelChat.id}\\`); // Add data attribute for identification\n                                panelChatHeader.innerHTML = \\`\n                                    Title: \\${escapeHtml(panelChat.customTitle)}\n                                    <button class=\"delete-panelchat-button\" data-id=\"\\${escapeHtml(panelChat.id)}\" title=\"Delete PanelChat\">🗑️</button>\n                                    <button \n                                        class=\"append-context-button\" \n                                        data-commit=\"\\${escapeHtml(commit.commitHash)}\" \n                                        data-id=\"\\${escapeHtml(panelChat.id)}\" \n                                        title=\"Append to context\"\n                                    >\n                                        📄\n                                    </button>\n                                \\`;\n\n                                // Determine if the commit is an uncommitted change\n                                const isUnadded = commit.commitHash === 'uncommitted';\n\n                                if (isUnadded) {\n                                    // Add Write Chat Button for Uncommitted Changes\n                                    panelChatHeader.innerHTML += \\`\n                                        <button \n                                            class=\"write-chat-button\" \n                                            data-panel-chat-id=\"\\${escapeHtml(panelChat.id)}\" \n                                            title=\"Write PanelChat to Stashed State\"\n                                        >\n                                            ➕\n                                        </button>\n                                    \\`;\n                                } else if (commit.commitHash === 'added') {\n                                    // Add Remove Chat Button for Added Changes\n                                    panelChatHeader.innerHTML += \\`\n                                        <button \n                                            class=\"remove-chat-button\" \n                                            data-panel-chat-id=\"\\${escapeHtml(panelChat.id)}\" \n                                            title=\"Remove PanelChat from Stashed State\"\n                                        >\n                                            ➖\n                                        </button>\n                                    \\`;\n                                }\n\n                                panelChatDiv.appendChild(panelChatHeader);\n\n                                // Create panel-chat-details container\n                                const panelChatDetails = document.createElement('div');\n                                panelChatDetails.className = 'panel-chat-details';\n\n                                // PanelChat info (customTitle, ai_editor, etc.)\n                                const panelChatInfo = document.createElement('div');\n                                panelChatInfo.className = 'panel-chat-info';\n                                panelChatInfo.innerHTML = \\`\n                                    <strong>AI Editor:</strong> \\${escapeHtml(panelChat.ai_editor)}<br>\n                                    <strong>Created On:</strong> \\${new Date(panelChat.created_on).toLocaleString()}<br>\n                                \\`;\n                                panelChatDetails.appendChild(panelChatInfo);\n\n                                // Messages in panelChat\n                                panelChat.messages.forEach(messageEntry => {\n                                    const messageContainer = document.createElement('div');\n                                    messageContainer.className = 'message-container';\n\n                                    // Delete button\n                                    const deleteBtn = document.createElement('button');\n                                    deleteBtn.className = 'delete-button';\n                                    deleteBtn.setAttribute('data-id', messageEntry.id);\n                                    deleteBtn.title = 'Delete Message';\n                                    deleteBtn.textContent = '×';\n                                    messageContainer.appendChild(deleteBtn);\n\n                                    // Determine if the commit is an uncommitted change\n                                    const isUnaddedMessage = commit.commitHash === 'uncommitted';\n\n                                    // Conditionally add Write or Remove Chat Buttons\n                                    if (isUnaddedMessage) {\n                                        // Add Write Chat Button for Messages\n                                        const writeBtn = document.createElement('button');\n                                        writeBtn.className = 'write-chat-button';\n                                        writeBtn.setAttribute('data-message-id', messageEntry.id); // Changed to 'data-message-id'\n                                        writeBtn.title = 'Write Message to Stashed State';\n                                        writeBtn.textContent = '➕';\n                                        messageContainer.appendChild(writeBtn);\n                                    } else if (commit.commitHash === 'added') {\n                                        // Add Remove Chat Button for Messages\n                                        const removeBtn = document.createElement('button');\n                                        removeBtn.className = 'remove-chat-button';\n                                        removeBtn.setAttribute('data-message-id', messageEntry.id); // Changed to 'data-message-id'\n                                        removeBtn.title = 'Remove Message from Stashed State';\n                                        removeBtn.textContent = '➖';\n                                        messageContainer.appendChild(removeBtn);\n                                    }\n\n                                    // Message Text\n                                    const messageDiv = document.createElement('div');\n                                    messageDiv.className = 'message';\n                                    messageDiv.innerHTML = escapeHtml(messageEntry.messageText);\n                                    messageContainer.appendChild(messageDiv);\n\n                                    // Response Text\n                                    const responseDiv = document.createElement('div');\n                                    responseDiv.className = 'response';\n                                    responseDiv.innerHTML = formatResponse(messageEntry.responseText);\n                                    messageContainer.appendChild(responseDiv);\n\n                                    // Additional Message Details\n                                    const messageDetails = document.createElement('div');\n                                    messageDetails.className = 'message-details';\n                                    messageDetails.style.fontSize = '0.8em';\n                                    messageDetails.style.color = 'var(--vscode-descriptionForeground)';\n                                    messageDetails.innerHTML = \\`\n                                        <strong>Model:</strong> \\${escapeHtml(messageEntry.model)}<br>\n                                        <strong>Timestamp:</strong> \\${new Date(messageEntry.timestamp).toLocaleString()}\n                                    \\`;\n                                    messageContainer.appendChild(messageDetails);\n\n                                    // Optionally, display context if needed\n                                    console.log('Message Entry Context:', messageEntry.context);\n                                    if (messageEntry.context && Array.isArray(messageEntry.context) && messageEntry.context.length > 0) {\n                                        const contextDiv = document.createElement('div');\n                                        contextDiv.className = 'context';\n                                        contextDiv.style.fontSize = '0.8em';\n                                        contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                                        const humanReadableContext = messageEntry.context\n                                        .filter(item => item && typeof item === 'object' && item.value && typeof item.value === 'object' && typeof item.value.human_readable === 'string')\n                                        .map(item => {\n                                            // Get the relative path\n                                            const fullPath = item.value.human_readable;\n                                            let relativePath = fullPath;\n                                            \n                                            if (workspaceFolderPath && fullPath.startsWith(workspaceFolderPath)) {\n                                                relativePath = fullPath.slice(workspaceFolderPath.length + 1);\n                                            }\n\n                                            const link = document.createElement('a');\n                                            link.href = '#';\n                                            link.textContent = escapeHtml(relativePath);\n                                            link.dataset.path = relativePath;\n                                            link.classList.add('context-link'); \n                                            return link.outerHTML;\n                                        })\n                                        .join(', ');\n                                        if (humanReadableContext) {\n                                            contextDiv.innerHTML = \\`<strong>Context:</strong> \\${humanReadableContext}\\`;\n                                            messageContainer.appendChild(contextDiv);\n                                        }\n                                    }\n\n                                    if (messageEntry.kv_store && 'file_paths' in messageEntry.kv_store) {\n                                        const contextDiv = document.createElement('div');\n                                        contextDiv.className = 'context';\n                                        contextDiv.style.fontSize = '0.8em';\n                                        contextDiv.style.color = 'var(--vscode-descriptionForeground)';\n                                        const associatedFilePaths = messageEntry.kv_store.file_paths\n                                        .map(filePath => {\n                                            let relativePath = filePath;\n                                            \n                                            if (workspaceFolderPath && filePath.startsWith(workspaceFolderPath)) {\n                                                relativePath = filePath.slice(workspaceFolderPath.length + 1);\n                                            }\n\n                                            const link = document.createElement('a');\n                                            link.href = '#';\n                                            link.textContent = escapeHtml(relativePath);\n                                            link.dataset.path = relativePath;\n                                            link.classList.add('context-link'); \n                                            return link.outerHTML;\n                                        })\n                                        .join(', ');\n                                        if (associatedFilePaths) {\n                                            contextDiv.innerHTML = \\`<strong>Associated Files:</strong> \\${associatedFilePaths}\\`;\n                                            messageContainer.appendChild(contextDiv);\n                                        }\n                                    }\n\n                                    panelChatDetails.appendChild(messageContainer);\n                                });\n\n                                commitDetails.appendChild(panelChatDetails);\n                                panelChatDiv.appendChild(panelChatDetails);\n\n                                commitDetails.appendChild(panelChatDiv);\n                            });\n                        } else {\n                            const noPanelChats = document.createElement('div');\n                            noPanelChats.className = 'no-messages';\n                            noPanelChats.textContent = 'No panelChats in this commit.';\n                            commitDetails.appendChild(noPanelChats);\n                        }\n\n                        commitDiv.appendChild(commitDetails);\n                        contentElement.appendChild(commitDiv);\n                    });\n\n                    // Attach event listeners for collapsible commits\n                    attachCommitToggleListeners();\n\n                    // Attach event listeners for collapsible panel chats\n                    attachPanelChatToggleListeners(); // New function call\n\n                    // Attach event listeners for delete, write, and remove buttons\n                    attachButtonListeners();\n\n                    attachLinkListeners();\n                } else {\n                    const noCommits = document.createElement('div');\n                    noCommits.className = 'no-commits';\n                    noCommits.textContent = 'No commits found.';\n                    contentElement.appendChild(noCommits);\n                }\n\n                // After updating the content\n                restoreExpandedCommits();\n                restoreExpandedPanelChats(); // Restore expanded panel chats\n                restoreScrollPosition();\n                Prism.highlightAll();\n            }\n        });\n\n        /**\n         * Notifies the extension that the Webview is ready.\n         */\n        // Notify the extension that the Webview is ready\n        vscode.postMessage({ command: 'webviewReady' });\n        //console.log('Webview is ready.');\n    </script>\n</body>\n</html>\n        `;\n    }\n\n}\n\n/**\n * Generates a random nonce for Content Security Policy.\n * @returns {string} - A random 32-character string.\n */\nfunction getNonce() {\n    let text = '';\n    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    for (let i = 0; i < 32; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n}\n"
            }
          ]
        }
      ],
      "selection": null,
      "timestamp": "2024-10-03T03:04:04.349Z",
      "prompt": "can we add posthog analytics for the number of inlineChats and panelChats saved?",
      "parent_inline_chat_id": null
    },
    {
      "inline_chat_id": "40a0afed-a324-4981-9834-f38dc5bbc5ae",
      "file_diff": [
        {
          "file_path": "src/identify_user.ts",
          "before_content": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        const firstCommitHash = await git.raw(['rev-list', '--parents', 'HEAD']).then(output => {\n            const lines = output.trim().split('\\n');\n            return lines[lines.length - 1].split(' ')[0];\n        });\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            context.globalState.update('posthog_id', hashedEmail);\n            context.globalState.update('email', trimmedEmail);\n            \n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n",
          "after_content": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        const firstCommitHash = await git.raw(['rev-list', '--parents', 'HEAD']).then(output => {\n            const lines = output.trim().split('\\n');\n            return lines[lines.length - 1].split(' ')[0];\n        });\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            context.globalState.update('posthog_id', hashedEmail);\n            context.globalState.update('email', trimmedEmail);\n            context.globalState.update('first_commit_hash', firstCommitHash);\n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n",
          "diffs": [
            {
              "count": 20,
              "added": false,
              "removed": false,
              "value": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        const firstCommitHash = await git.raw(['rev-list', '--parents', 'HEAD']).then(output => {\n            const lines = output.trim().split('\\n');\n            return lines[lines.length - 1].split(' ')[0];\n        });\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            context.globalState.update('posthog_id', hashedEmail);\n            context.globalState.update('email', trimmedEmail);\n"
            },
            {
              "count": 1,
              "added": false,
              "removed": true,
              "value": "            \n"
            },
            {
              "count": 1,
              "added": true,
              "removed": false,
              "value": "            context.globalState.update('first_commit_hash', firstCommitHash);\n"
            },
            {
              "count": 8,
              "added": false,
              "removed": false,
              "value": "            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n"
            }
          ]
        }
      ],
      "selection": null,
      "timestamp": "2024-10-03T03:20:58.553Z",
      "prompt": "run git rev-list --parents HEAD | tail -1 using simplegit\n",
      "parent_inline_chat_id": null
    },
    {
      "inline_chat_id": "9356d29b-47b1-47db-a813-a5b7d986f546",
      "file_diff": [
        {
          "file_path": "src/identify_user.ts",
          "before_content": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n",
          "after_content": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n\nexport async function identifyRepo(context: vscode.ExtensionContext): Promise<void> {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder) {\n        return;\n    }\n    const repoPath = workspaceFolder.uri.fsPath;\n    const git: SimpleGit = simpleGit(repoPath);\n    \n}",
          "diffs": [
            {
              "count": 22,
              "added": false,
              "removed": false,
              "value": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n"
            },
            {
              "count": 10,
              "added": true,
              "removed": false,
              "value": "\nexport async function identifyRepo(context: vscode.ExtensionContext): Promise<void> {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder) {\n        return;\n    }\n    const repoPath = workspaceFolder.uri.fsPath;\n    const git: SimpleGit = simpleGit(repoPath);\n    \n}"
            }
          ]
        }
      ],
      "selection": null,
      "timestamp": "2024-10-03T03:40:17.276Z",
      "prompt": "if the repo global state doesnt exist, set it to the first ocmmit hash of the repo",
      "parent_inline_chat_id": null
    },
    {
      "inline_chat_id": "d04a42b3-5d37-44d0-9736-5cfcc17affd2",
      "file_diff": [
        {
          "file_path": "src/identify_user.ts",
          "before_content": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n\nexport async function identifyRepo(context: vscode.ExtensionContext): Promise<void> {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder) {\n        return;\n    }\n    // Check if repo global state exists, if not, set it to the first commit hash\n    const repoGlobalState = context.globalState.get('repoGlobalState');\n    if (!repoGlobalState) {\n        try {\n            const git: SimpleGit = simpleGit(workspaceFolder.uri.fsPath);\n            const log = await git.raw('rev-list', '--parents', 'HEAD');\n            const firstCommitHash = log.split('\\n')[-1];\n        } catch (error) {\n            console.error('Error getting first commit hash:', error);\n        }\n    }   \n}",
          "after_content": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n\nexport async function identifyRepo(context: vscode.ExtensionContext): Promise<void> {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder) {\n        return;\n    }\n    // Check if repo global state exists, if not, set it to the first commit hash\n    const repoGlobalState = context.globalState.get('repoGlobalState');\n    if (!repoGlobalState) {\n        try {\n            const git: SimpleGit = simpleGit(workspaceFolder.uri.fsPath);\n            const log = await git.raw('rev-list', '--max-parents=0', 'HEAD');\n            const firstCommitHash = log.trim();\n            context.globalState.update('repoGlobalState', firstCommitHash);\n        } catch (error) {\n            console.error('Error getting first commit hash:', error);\n        }\n    }   \n}",
          "diffs": [
            {
              "count": 33,
              "added": false,
              "removed": false,
              "value": "import posthog from \"posthog-js\";\n\nimport simpleGit, { SimpleGit } from 'simple-git';\nimport * as vscode from 'vscode';\nimport * as crypto from 'crypto';\n\nexport async function identifyUser(context: vscode.ExtensionContext): Promise<void> {\n    const git: SimpleGit = simpleGit();\n    \n    try {\n        const userEmail = await git.raw(['config', '--get', 'user.email']);\n        const trimmedEmail = userEmail.trim();\n        if (trimmedEmail) {\n            const hashedEmail = crypto.createHash('sha256').update(trimmedEmail).digest('hex');\n            posthog.identify(hashedEmail, { email: trimmedEmail });\n        } else {\n            console.log('No Git user email found');\n        }\n    } catch (error) {\n        console.error('Error identifying user:', error);\n    }\n}\n\nexport async function identifyRepo(context: vscode.ExtensionContext): Promise<void> {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder) {\n        return;\n    }\n    // Check if repo global state exists, if not, set it to the first commit hash\n    const repoGlobalState = context.globalState.get('repoGlobalState');\n    if (!repoGlobalState) {\n        try {\n            const git: SimpleGit = simpleGit(workspaceFolder.uri.fsPath);\n"
            },
            {
              "count": 2,
              "added": false,
              "removed": true,
              "value": "            const log = await git.raw('rev-list', '--parents', 'HEAD');\n            const firstCommitHash = log.split('\\n')[-1];\n"
            },
            {
              "count": 3,
              "added": true,
              "removed": false,
              "value": "            const log = await git.raw('rev-list', '--max-parents=0', 'HEAD');\n            const firstCommitHash = log.trim();\n            context.globalState.update('repoGlobalState', firstCommitHash);\n"
            },
            {
              "count": 5,
              "added": false,
              "removed": false,
              "value": "        } catch (error) {\n            console.error('Error getting first commit hash:', error);\n        }\n    }   \n}"
            }
          ]
        }
      ],
      "selection": null,
      "timestamp": "2024-10-03T03:48:18.866Z",
      "prompt": "this gets the last one, not the first one",
      "parent_inline_chat_id": null
    },
    {
      "inline_chat_id": "efb6c496-b46e-40d2-8ee1-5f95e3300c0b",
      "file_diff": [
        {
          "file_path": "src/inlinehover.ts",
          "before_content": "import * as vscode from 'vscode';\nimport * as Inline from './inline';\nimport * as Diff from 'diff';\nimport * as path from 'path';\nimport { CommitData, getInlineChatIdToCommitInfo } from './panelgit';\nimport { getRelativePath } from './utils';\nimport { getInlineParent } from './stashedState';\nimport { STASHED_GAIT_STATE_FILE_NAME } from './constants';\n\nexport async function createHoverContent(context: vscode.ExtensionContext, markdown: vscode.MarkdownString, inlineChat: Inline.InlineChatInfo, document: vscode.TextDocument, matchedRange: Inline.InlineMatchedRange | null = null, idToCommitInfo: Map<String, CommitData> | undefined): Promise<vscode.MarkdownString> {\n    const { prompt, timestamp, parent_inline_chat_id } = inlineChat;\n\n    // Find the diff that matches the current document's file path\n    const documentPath = getRelativePath(document);\n    const matchingDiff = inlineChat.file_diff.find(diff => path.normalize(diff.file_path) === path.normalize(documentPath));\n    \n    // Set diffs to the matching diff's diffs, or an empty array if no match found\n    const diffs = matchingDiff ? matchingDiff.diffs : [];\n    // Log an error if no matching diff is found\n    if (!matchingDiff) {\n        console.error(`No matching diff found for document path: ${documentPath}`);\n        throw new Error(`No matching diff found for document path: ${documentPath}`);\n    }\n\n    const commitInfo = idToCommitInfo?.get(inlineChat.inline_chat_id);\n\n    const author = commitInfo?.author ?? \"You\";\n    const commitMessage = commitInfo?.commitMessage;\n    const commitHash = commitInfo?.commitHash ?? \"uncommitted chat\";\n\n    //markdown.supportHtml = true; // Allows HTML in the Markdown\n    markdown.isTrusted = true; // Allows advanced Markdown features\n\n    // Display the prompt with a smaller, circular user icon\n    const timeDiffMs = new Date().getTime() - new Date(timestamp).getTime();\n    const hoursSinceEdit = Math.floor(timeDiffMs / (1000 * 3600));\n    const daysSinceEdit = Math.floor(timeDiffMs / (1000 * 3600 * 24));\n    const timeAgo = daysSinceEdit === 0 ? `${hoursSinceEdit} hours ago` : daysSinceEdit === 1 ? 'yesterday' : `${daysSinceEdit} days ago`;\n    markdown.appendMarkdown(`### ${author ?? \"You\"}: ${prompt} (${new Date(timestamp).toISOString().split('T')[0]}) (${timeAgo}) \\n\\n---\\n`);\n    markdown.appendMarkdown(`**Commit**: ${commitMessage} (${commitHash}) \\n\\n---\\n`);\n    // Flatten the diffs into individual lines\n    let lineBasedDiffs: Diff.Change[] = [];\n    diffs.forEach(diff => {\n        const diffLines = diff.value.split('\\n');\n        diffLines.forEach(line => {\n            lineBasedDiffs.push({\n                value: line,\n                added: diff.added,\n                removed: diff.removed\n            });\n        });\n    });\n\n    // Find all lines that match `matchedLines`\n    let surroundingLines: Diff.Change[] = lineBasedDiffs.filter(diff => diff.added || diff.removed);\n\n    // Ensure that there are lines to display\n    if (surroundingLines.length > 0) {\n        const diffText = surroundingLines.map(change => {\n            if (change.added) {return `+ ${change.value}`;}\n            if (change.removed) {return `- ${change.value}`;}\n            return `  ${change.value}`;\n        }).join('\\n');\n        markdown.appendCodeblock('\\n'+diffText, 'diff');\n    }\n    // Add action buttons at the end of the hover content\n    markdown.appendMarkdown(`\\n\\n`);\n    const deleteCommand = vscode.Uri.parse(`command:gait-copilot.removeInlineChat?${encodeURIComponent(JSON.stringify({\n        filePath: vscode.workspace.asRelativePath(document.uri),\n        inline_chat_id: inlineChat.inline_chat_id\n    }))}`);\n    \n    markdown.appendMarkdown(`[View File at Prompt Time](${openFileCommand}) | ` +\n                          `[Delete This Inline Chat Annotation](${deleteCommand})`);\n    if (parent_inline_chat_id) {\n        // Load the parent inline chat\n        const parentInlineChat = getInlineParent(context, parent_inline_chat_id);\n        if (!parentInlineChat) {\n            console.error(`Parent inline chat not found for ID: ${parent_inline_chat_id}`);\n        } else {\n            markdown.appendMarkdown('\\n\\n---\\n\\n**Parent Chat:**\\n\\n');\n            createHoverContent(context, markdown, parentInlineChat, document, null, idToCommitInfo);\n        }\n    }\n    return markdown;\n}\n\nexport async function createHover(context: vscode.ExtensionContext, matchedRange: Inline.InlineMatchedRange, document: vscode.TextDocument): Promise<vscode.ProviderResult<vscode.Hover>> {\n    let markdown = new vscode.MarkdownString();\n\n    let idToCommitInfo = undefined;\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    const filePath = `.gait/${STASHED_GAIT_STATE_FILE_NAME}`; // Replace with your actual file path relative to repo\n\n    if (!workspaceFolder) {\n        console.warn('No workspace folder found.');\n    } else {\n        try {\n            idToCommitInfo = await getInlineChatIdToCommitInfo(context, workspaceFolder.uri.fsPath, filePath);\n        } catch (error) {\n            console.warn(`Error getting commit info for ${document.fileName}: ${error}`);\n        }\n    }\n    markdown = await createHoverContent(context, markdown, matchedRange.inlineChat, document, matchedRange, idToCommitInfo);\n    return new vscode.Hover(markdown);\n}\n",
          "after_content": "import * as vscode from 'vscode';\nimport * as Inline from './inline';\nimport * as Diff from 'diff';\nimport * as path from 'path';\nimport { CommitData, getInlineChatIdToCommitInfo } from './panelgit';\nimport { getRelativePath } from './utils';\nimport { getInlineParent } from './stashedState';\nimport { STASHED_GAIT_STATE_FILE_NAME } from './constants';\n\nexport async function createHoverContent(context: vscode.ExtensionContext, markdown: vscode.MarkdownString, inlineChat: Inline.InlineChatInfo, document: vscode.TextDocument, matchedRange: Inline.InlineMatchedRange | null = null, idToCommitInfo: Map<String, CommitData> | undefined): Promise<vscode.MarkdownString> {\n    const { prompt, timestamp, parent_inline_chat_id } = inlineChat;\n\n    // Find the diff that matches the current document's file path\n    const documentPath = getRelativePath(document);\n    const matchingDiff = inlineChat.file_diff.find(diff => path.normalize(diff.file_path) === path.normalize(documentPath));\n    \n    // Set diffs to the matching diff's diffs, or an empty array if no match found\n    const diffs = matchingDiff ? matchingDiff.diffs : [];\n    // Log an error if no matching diff is found\n    if (!matchingDiff) {\n        console.error(`No matching diff found for document path: ${documentPath}`);\n        throw new Error(`No matching diff found for document path: ${documentPath}`);\n    }\n\n    const commitInfo = idToCommitInfo?.get(inlineChat.inline_chat_id);\n\n    const author = commitInfo?.author ?? \"You\";\n    const commitMessage = commitInfo?.commitMessage;\n    const commitHash = commitInfo?.commitHash ?? \"uncommitted chat\";\n\n    //markdown.supportHtml = true; // Allows HTML in the Markdown\n    markdown.isTrusted = true; // Allows advanced Markdown features\n\n    // Display the prompt with a smaller, circular user icon\n    const timeDiffMs = new Date().getTime() - new Date(timestamp).getTime();\n    const hoursSinceEdit = Math.floor(timeDiffMs / (1000 * 3600));\n    const daysSinceEdit = Math.floor(timeDiffMs / (1000 * 3600 * 24));\n    const timeAgo = daysSinceEdit === 0 ? `${hoursSinceEdit} hours ago` : daysSinceEdit === 1 ? 'yesterday' : `${daysSinceEdit} days ago`;\n    markdown.appendMarkdown(`### ${author ?? \"You\"}: ${prompt} (${new Date(timestamp).toISOString().split('T')[0]}) (${timeAgo}) \\n\\n---\\n`);\n    markdown.appendMarkdown(`**Commit**: ${commitMessage} (${commitHash}) \\n\\n---\\n`);\n    // Flatten the diffs into individual lines\n    let lineBasedDiffs: Diff.Change[] = [];\n    diffs.forEach(diff => {\n        const diffLines = diff.value.split('\\n');\n        diffLines.forEach(line => {\n            lineBasedDiffs.push({\n                value: line,\n                added: diff.added,\n                removed: diff.removed\n            });\n        });\n    });\n\n    // Find all lines that match `matchedLines`\n    let surroundingLines: Diff.Change[] = lineBasedDiffs.filter(diff => diff.added || diff.removed);\n\n    // Ensure that there are lines to display\n    if (surroundingLines.length > 0) {\n        const diffText = surroundingLines.map(change => {\n            if (change.added) {return `+ ${change.value}`;}\n            if (change.removed) {return `- ${change.value}`;}\n            return `  ${change.value}`;\n        }).join('\\n');\n        markdown.appendCodeblock('\\n'+diffText, 'diff');\n    }\n    // Add action buttons at the end of the hover content\n    markdown.appendMarkdown(`\\n\\n`);\n    const deleteCommand = vscode.Uri.parse(`command:gait-copilot.removeInlineChat?${encodeURIComponent(JSON.stringify({\n        filePath: vscode.workspace.asRelativePath(document.uri),\n        inline_chat_id: inlineChat.inline_chat_id\n    }))}`);\n    // Add a button to view only removed lines\n    const removedLinesCommand = vscode.Uri.parse(`command:gait-copilot.viewRemovedLines?${encodeURIComponent(JSON.stringify({\n        diffs: matchingDiff.diffs.filter(diff => diff.removed)\n    }))}`);\n    markdown.appendMarkdown(`[View Removed Lines](${removedLinesCommand}) | `);\n\n    const openFileCommand = vscode.Uri.parse(`command:gait-copilot.openFileWithContent?${encodeURIComponent(JSON.stringify({\n        content: matchingDiff.before_content,\n        title: `${path.basename(matchingDiff.file_path)} (at prompt time)`,\n        languageId: vscode.window.activeTextEditor?.document.languageId,\n        selectionStart: inlineChat.selection?.startSelection,\n        selectionEnd: inlineChat.selection?.endSelection\n    }))}`);\n    \n    markdown.appendMarkdown(`[View File at Prompt Time](${openFileCommand}) | ` +\n                          `[Delete This Inline Chat Annotation](${deleteCommand})`);\n    if (parent_inline_chat_id) {\n        // Load the parent inline chat\n        const parentInlineChat = getInlineParent(context, parent_inline_chat_id);\n        if (!parentInlineChat) {\n            console.error(`Parent inline chat not found for ID: ${parent_inline_chat_id}`);\n        } else {\n            markdown.appendMarkdown('\\n\\n---\\n\\n**Parent Chat:**\\n\\n');\n            createHoverContent(context, markdown, parentInlineChat, document, null, idToCommitInfo);\n        }\n    }\n    return markdown;\n}\n\nexport async function createHover(context: vscode.ExtensionContext, matchedRange: Inline.InlineMatchedRange, document: vscode.TextDocument): Promise<vscode.ProviderResult<vscode.Hover>> {\n    let markdown = new vscode.MarkdownString();\n\n    let idToCommitInfo = undefined;\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    const filePath = `.gait/${STASHED_GAIT_STATE_FILE_NAME}`; // Replace with your actual file path relative to repo\n\n    if (!workspaceFolder) {\n        console.warn('No workspace folder found.');\n    } else {\n        try {\n            idToCommitInfo = await getInlineChatIdToCommitInfo(context, workspaceFolder.uri.fsPath, filePath);\n        } catch (error) {\n            console.warn(`Error getting commit info for ${document.fileName}: ${error}`);\n        }\n    }\n    markdown = await createHoverContent(context, markdown, matchedRange.inlineChat, document, matchedRange, idToCommitInfo);\n    return new vscode.Hover(markdown);\n}\n",
          "diffs": [
            {
              "count": 71,
              "added": false,
              "removed": false,
              "value": "import * as vscode from 'vscode';\nimport * as Inline from './inline';\nimport * as Diff from 'diff';\nimport * as path from 'path';\nimport { CommitData, getInlineChatIdToCommitInfo } from './panelgit';\nimport { getRelativePath } from './utils';\nimport { getInlineParent } from './stashedState';\nimport { STASHED_GAIT_STATE_FILE_NAME } from './constants';\n\nexport async function createHoverContent(context: vscode.ExtensionContext, markdown: vscode.MarkdownString, inlineChat: Inline.InlineChatInfo, document: vscode.TextDocument, matchedRange: Inline.InlineMatchedRange | null = null, idToCommitInfo: Map<String, CommitData> | undefined): Promise<vscode.MarkdownString> {\n    const { prompt, timestamp, parent_inline_chat_id } = inlineChat;\n\n    // Find the diff that matches the current document's file path\n    const documentPath = getRelativePath(document);\n    const matchingDiff = inlineChat.file_diff.find(diff => path.normalize(diff.file_path) === path.normalize(documentPath));\n    \n    // Set diffs to the matching diff's diffs, or an empty array if no match found\n    const diffs = matchingDiff ? matchingDiff.diffs : [];\n    // Log an error if no matching diff is found\n    if (!matchingDiff) {\n        console.error(`No matching diff found for document path: ${documentPath}`);\n        throw new Error(`No matching diff found for document path: ${documentPath}`);\n    }\n\n    const commitInfo = idToCommitInfo?.get(inlineChat.inline_chat_id);\n\n    const author = commitInfo?.author ?? \"You\";\n    const commitMessage = commitInfo?.commitMessage;\n    const commitHash = commitInfo?.commitHash ?? \"uncommitted chat\";\n\n    //markdown.supportHtml = true; // Allows HTML in the Markdown\n    markdown.isTrusted = true; // Allows advanced Markdown features\n\n    // Display the prompt with a smaller, circular user icon\n    const timeDiffMs = new Date().getTime() - new Date(timestamp).getTime();\n    const hoursSinceEdit = Math.floor(timeDiffMs / (1000 * 3600));\n    const daysSinceEdit = Math.floor(timeDiffMs / (1000 * 3600 * 24));\n    const timeAgo = daysSinceEdit === 0 ? `${hoursSinceEdit} hours ago` : daysSinceEdit === 1 ? 'yesterday' : `${daysSinceEdit} days ago`;\n    markdown.appendMarkdown(`### ${author ?? \"You\"}: ${prompt} (${new Date(timestamp).toISOString().split('T')[0]}) (${timeAgo}) \\n\\n---\\n`);\n    markdown.appendMarkdown(`**Commit**: ${commitMessage} (${commitHash}) \\n\\n---\\n`);\n    // Flatten the diffs into individual lines\n    let lineBasedDiffs: Diff.Change[] = [];\n    diffs.forEach(diff => {\n        const diffLines = diff.value.split('\\n');\n        diffLines.forEach(line => {\n            lineBasedDiffs.push({\n                value: line,\n                added: diff.added,\n                removed: diff.removed\n            });\n        });\n    });\n\n    // Find all lines that match `matchedLines`\n    let surroundingLines: Diff.Change[] = lineBasedDiffs.filter(diff => diff.added || diff.removed);\n\n    // Ensure that there are lines to display\n    if (surroundingLines.length > 0) {\n        const diffText = surroundingLines.map(change => {\n            if (change.added) {return `+ ${change.value}`;}\n            if (change.removed) {return `- ${change.value}`;}\n            return `  ${change.value}`;\n        }).join('\\n');\n        markdown.appendCodeblock('\\n'+diffText, 'diff');\n    }\n    // Add action buttons at the end of the hover content\n    markdown.appendMarkdown(`\\n\\n`);\n    const deleteCommand = vscode.Uri.parse(`command:gait-copilot.removeInlineChat?${encodeURIComponent(JSON.stringify({\n        filePath: vscode.workspace.asRelativePath(document.uri),\n        inline_chat_id: inlineChat.inline_chat_id\n    }))}`);\n"
            },
            {
              "count": 13,
              "added": true,
              "removed": false,
              "value": "    // Add a button to view only removed lines\n    const removedLinesCommand = vscode.Uri.parse(`command:gait-copilot.viewRemovedLines?${encodeURIComponent(JSON.stringify({\n        diffs: matchingDiff.diffs.filter(diff => diff.removed)\n    }))}`);\n    markdown.appendMarkdown(`[View Removed Lines](${removedLinesCommand}) | `);\n\n    const openFileCommand = vscode.Uri.parse(`command:gait-copilot.openFileWithContent?${encodeURIComponent(JSON.stringify({\n        content: matchingDiff.before_content,\n        title: `${path.basename(matchingDiff.file_path)} (at prompt time)`,\n        languageId: vscode.window.activeTextEditor?.document.languageId,\n        selectionStart: inlineChat.selection?.startSelection,\n        selectionEnd: inlineChat.selection?.endSelection\n    }))}`);\n"
            },
            {
              "count": 35,
              "added": false,
              "removed": false,
              "value": "    \n    markdown.appendMarkdown(`[View File at Prompt Time](${openFileCommand}) | ` +\n                          `[Delete This Inline Chat Annotation](${deleteCommand})`);\n    if (parent_inline_chat_id) {\n        // Load the parent inline chat\n        const parentInlineChat = getInlineParent(context, parent_inline_chat_id);\n        if (!parentInlineChat) {\n            console.error(`Parent inline chat not found for ID: ${parent_inline_chat_id}`);\n        } else {\n            markdown.appendMarkdown('\\n\\n---\\n\\n**Parent Chat:**\\n\\n');\n            createHoverContent(context, markdown, parentInlineChat, document, null, idToCommitInfo);\n        }\n    }\n    return markdown;\n}\n\nexport async function createHover(context: vscode.ExtensionContext, matchedRange: Inline.InlineMatchedRange, document: vscode.TextDocument): Promise<vscode.ProviderResult<vscode.Hover>> {\n    let markdown = new vscode.MarkdownString();\n\n    let idToCommitInfo = undefined;\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    const filePath = `.gait/${STASHED_GAIT_STATE_FILE_NAME}`; // Replace with your actual file path relative to repo\n\n    if (!workspaceFolder) {\n        console.warn('No workspace folder found.');\n    } else {\n        try {\n            idToCommitInfo = await getInlineChatIdToCommitInfo(context, workspaceFolder.uri.fsPath, filePath);\n        } catch (error) {\n            console.warn(`Error getting commit info for ${document.fileName}: ${error}`);\n        }\n    }\n    markdown = await createHoverContent(context, markdown, matchedRange.inlineChat, document, matchedRange, idToCommitInfo);\n    return new vscode.Hover(markdown);\n}\n"
            }
          ]
        }
      ],
      "selection": null,
      "timestamp": "2024-10-03T04:29:23.809Z",
      "prompt": "iterate through matchingDiff.diffs but filter out those that are added",
      "parent_inline_chat_id": null
    },
    {
      "inline_chat_id": "f1870fa1-97a0-4b66-8984-825f5f00a81a",
      "file_diff": [
        {
          "file_path": "src/filedecoration.ts",
          "diffs": [
            {
              "count": 88,
              "added": false,
              "removed": false,
              "value": "import * as vscode from 'vscode';\nimport * as Inline from './inline';\nimport * as Diff from 'diff';\nimport * as levenshtein from 'fast-levenshtein';\nimport * as path from 'path';\nimport * as InlineHover from './inlinehover';\nimport { associateFileWithMessage } from './panelChats';\nimport { MessageEntry, PanelChat, PanelMatchedRange, StashedState } from './types';\nimport { readStashedState } from './stashedState';\nimport * as PanelHover from './panelHover';\nimport posthog from 'posthog-js';\ntype ColorType = 'blue' | 'green' | 'purple' | 'orange';\n\nconst colorHueMap: Record<ColorType, number> = {\n    blue: 210,\n    green: 110,\n    purple: 270,\n    orange: 30,\n};\n\n/**\n * Utility function to generate different colors with similar lightness.\n * Ensures colors are distinct by cycling through different hues.\n */\nfunction generateColors(index: number): string {\n    const colorTypes: ColorType[] = ['blue', 'green', 'purple', 'orange'];\n    const hue = colorHueMap[colorTypes[index % colorTypes.length]];\n    const saturation = 30;\n    const lightness = 75;\n    return `hsla(${hue}, ${saturation}%, ${lightness}%, 0.5)`;\n}\n\n/**\n * Extracts code blocks demarcated by triple backticks from a given text.\n * Handles optional language specifiers after the opening backticks.\n * @param text The text to extract code blocks from.\n * @returns An array of code blocks.\n */\nfunction extractCodeBlocks(text: string): string[] {\n    const codeBlockRegex = /```(?:\\w+)?\\s*([\\s\\S]*?)```/g;\n    const codeBlocks: string[] = [];\n    let match;\n    while ((match = codeBlockRegex.exec(text)) !== null) {\n        codeBlocks.push(match[1].trim());\n    }\n    return codeBlocks;\n}\n\nexport function matchDiffToCurrentFile(\n    document: vscode.TextDocument,\n    diff: Diff.Change[]\n): vscode.Range[] {\n    const documentLines = document.getText().split('\\n');\n\n    // Extract all added lines from the diff and create a Set for faster lookup\n    const addedLinesSet = new Set(\n        diff.filter(change => change.added)\n           .flatMap(change => change.value.split('\\n').map(line => line.trim()))\n           .filter(line => line.trim().length > 0)\n    );\n\n    if (addedLinesSet.size === 0) {\n        return [];\n    }\n\n    const matchingLineNumbers: number[] = [];\n\n    // Collect all matching line numbers\n    for (let i = 0; i < documentLines.length; i++) {\n        const trimmedLine = documentLines[i].trim();\n        if (addedLinesSet.has(trimmedLine)) {\n            matchingLineNumbers.push(i);\n        }\n    }\n\n    // Merge consecutive line numbers into ranges\n    const ranges: vscode.Range[] = [];\n    // Filter out ranges that are a single line\n    if (addedLinesSet.size < 5) {\n        return matchingLineNumbers.map(line => new vscode.Range(line, 0, line, documentLines[line].length));\n    }\n    let start = -1;\n    let end = -1;\n    const multiLineRanges: vscode.Range[] = [];\n\n    if (matchingLineNumbers.length > 0.8 * addedLinesSet.size) {\n        return matchingLineNumbers.map(line => new vscode.Range(line, 0, line, documentLines[line].length));\n    }\n"
            },
            {
              "count": 3,
              "added": true,
              "removed": false,
              "value": "    if (matchingLineNumbers.length < 0.2 * addedLinesSet.size) {\n        return [];\n    }\n"
            },
            {
              "count": 1,
              "added": false,
              "removed": false,
              "value": "\n"
            },
            {
              "count": 1,
              "added": true,
              "removed": false,
              "value": "\n"
            },
            {
              "count": 237,
              "added": false,
              "removed": false,
              "value": "    for (let i = 0; i < matchingLineNumbers.length; i++) {\n        const currentLine = matchingLineNumbers[i];\n        const nextLine = matchingLineNumbers[i + 1];\n\n        if (start === -1) {\n            start = currentLine;\n        }\n\n        if (nextLine === undefined || nextLine !== currentLine + 1) {\n            end = currentLine;\n\n            // Check if the range is meaningful\n            let meaningfulLines = 0;\n            for (let j = start; j <= end; j++) {\n                const line = documentLines[j].trim();\n                if (/[a-zA-Z0-9]/.test(line)) {\n                    meaningfulLines++;\n                }\n            }\n\n            // If we have at least two meaningful lines, add the range\n            if (meaningfulLines >= 2) {\n                for (let j = start; j <= end; j++) {\n                    multiLineRanges.push(new vscode.Range(j, 0, j, documentLines[j].length));\n                }\n            }\n\n            start = -1;\n            end = -1;\n        }\n    }\n\n    return multiLineRanges;\n}\n\n\nexport function decorateActive(context: vscode.ExtensionContext, decorations_active: boolean) {\n    const editor = vscode.window.activeTextEditor;\n    \n    if (!editor) {\n        return;\n    }\n\n    const baseName = vscode.workspace.asRelativePath(editor.document.uri);\n    if (baseName === 'gait_context.md' || baseName === '.gait/state.json') {\n        return;\n    }\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder) {\n        console.error('No workspace folder found');\n        return;\n    }\n\n    const stashedState: StashedState = readStashedState(context);\n    const inlineChats = stashedState.inlineChats;\n    if (inlineChats === undefined) {\n        vscode.window.showErrorMessage('No inline chats found');\n        return;\n    }\n    const rangesToPanel: PanelMatchedRange[] = [];\n    interface LineDecoration {\n        timestamp: number;\n        type: 'inline' | 'panel';\n        decorationType: vscode.TextEditorDecorationType;\n        decorationOptions: vscode.DecorationOptions[];\n    }\n\n    const lineDecorations: Map<number, LineDecoration> = new Map();\n\n    function addDecorationType(color: string, line: number, timestamp: number, type: 'inline' | 'panel') {\n        if (!decorations_active) {\n            return;\n        }\n        const decorationType = vscode.window.createTextEditorDecorationType({\n            backgroundColor: color,\n            overviewRulerColor: color,\n            overviewRulerLane: vscode.OverviewRulerLane.Right,\n            // You can add more styling options here if needed\n        });\n        const decorationOptions: vscode.DecorationOptions[] = [{\n            range: new vscode.Range(line, 0, line, editor!.document.lineAt(line).text.length),\n        }];\n\n        const existingDecoration = lineDecorations.get(line);\n        if (!existingDecoration || (timestamp < existingDecoration.timestamp)) {\n            lineDecorations.set(line, { timestamp, decorationType, decorationOptions, type });\n        }\n    }\n\n    let decorationIndex = 0;\n    const rangesToInline: Inline.InlineMatchedRange[] = [];\n    for (const chat of Object.values(inlineChats)) {\n        for (const diff of chat.file_diff) {\n            if (diff.file_path !== baseName) {\n                continue;\n            }\n            const currentRanges = matchDiffToCurrentFile(editor.document, diff.diffs);\n            if (currentRanges.length > 0) {\n                decorationIndex += 1;\n                const color = generateColors(decorationIndex);\n                // Get content at document in the range\n\n                // Create a new decoration type with the unique color\n                currentRanges.forEach(range => {\n                    rangesToInline.push({\n                        range: range,\n                        inlineChat: chat,\n                    });\n                    addDecorationType(color, range.start.line, new Date(chat.timestamp).getTime(), 'inline');\n                });\n            }\n        }\n    }\n    \n    const allPanelChats = [...stashedState.panelChats, ...(context.workspaceState.get<PanelChat[]>('currentPanelChats') || [])];\n// Filter out deleted panel chats\n    const currentPanelChats = allPanelChats.filter(chat => \n        !stashedState.deletedChats.deletedPanelChatIDs.includes(chat.id)\n    );\n    const currentMessages = currentPanelChats.reduce((acc, panelChat) => {\n        panelChat.messages.forEach(message => {\n            if (stashedState.deletedChats.deletedMessageIDs.includes(message.id)) {\n                return;\n            }\n            const existingIndex = acc.findIndex(item => item.message.id === message.id);\n            if (existingIndex === -1) {\n                acc.push({ message, panelChat });\n            }\n        });\n        return acc;\n    }, [] as { message: MessageEntry, panelChat: PanelChat }[]);\n\n\n\n    for (const {message, panelChat} of currentMessages) {\n        if (message.kv_store && 'file_paths' in message.kv_store && !message.kv_store.file_paths.includes(baseName)) {\n            continue;\n        }\n        const already_associated = (message.kv_store?.file_paths ?? []).includes(baseName);\n        if (already_associated) {\n            console.log(\"Already associated: \", message.id);\n        }\n        const codeBlocks = extractCodeBlocks(message.responseText);\n        for (const code of codeBlocks) {\n            const currentRanges = matchDiffToCurrentFile(editor.document, [{value: code, added: true}] as Diff.Change[]);\n            if (!already_associated && currentRanges.reduce((sum, range) => sum + (range.end.line - range.start.line + 1), 0) > code.split('\\n').length / 2) {\n                // If more than half of the code lines match, associate the file with the message\n                associateFileWithMessage(context, message, baseName, panelChat).catch(error => {\n                    console.error(`Failed to associate file with message: ${error}`);\n                });\n            }\n            if (currentRanges.length > 0) {\n                decorationIndex += 1;\n                const color = generateColors(decorationIndex);\n\n                function lineInRangesToPanel(line: number) {\n                    return rangesToPanel.some(range => \n                        range.range.start.line <= line && \n                        range.range.end.line >= line\n                    );\n                }\n                function addRange(range: vscode.Range) {\n                    rangesToPanel.push({\n                        range: range,\n                        panelChat: panelChat,\n                        message_id: message.id,\n                    });\n                    addDecorationType(color, range.start.line, new Date(panelChat.created_on).getTime(), 'panel');\n                }\n\n                currentRanges.forEach(range => {\n                    let currentStart = range.start.line;\n                    let currentEnd = currentStart;\n\n                    for (let i = range.start.line; i <= range.end.line; i++) {\n                        if (lineInRangesToPanel(i)) {\n                            if (currentStart !== currentEnd) {\n                                addRange(new vscode.Range(currentStart, 0, currentEnd, editor.document.lineAt(currentEnd).text.length));\n                            }\n                            currentStart = i + 1;\n                            currentEnd = i + 1;\n                        } else {\n                            currentEnd = i;\n                        }\n                    }\n\n                    if (currentStart <= range.end.line) {\n                        addRange(new vscode.Range(currentStart, 0, currentEnd, editor.document.lineAt(currentEnd).text.length));\n                    }\n                });\n            }\n        }\n    }\n\n    // Apply all decoration types\n    if (decorations_active) {\n        lineDecorations.forEach((value) => {\n            editor.setDecorations(value.decorationType, value.decorationOptions);\n            // Ensure decorationType is disposed when no longer needed\n            context.subscriptions.push(value.decorationType);\n        });\n    }\n\n    const hoverProvider = vscode.languages.registerHoverProvider('*', {\n        async provideHover(document, position, token) {\n            const ranges = rangesToInline.filter(matchedRange => matchedRange.range.contains(position));\n            if (ranges.length === 0) {\n                const panelRanges = rangesToPanel.filter(matchedRange => matchedRange.range.contains(position));\n                if (panelRanges.length === 0) {\n                    return undefined;\n                }\n                const oldestRange = panelRanges.reduce((max, current) => \n                    current.panelChat.created_on < max.panelChat.created_on ? current : max\n                );\n                posthog.capture('panel_hover');\n                const hover = await PanelHover.createPanelHover(context, oldestRange, editor.document);\n                return hover;\n            }\n            const oldestRange = ranges.reduce((max, current) => \n                current.inlineChat.timestamp < max.inlineChat.timestamp ? current : max\n            );\n            posthog.capture('inline_hover');\n            const hover = await InlineHover.createHover(context, oldestRange, editor.document);\n            return hover;\n        }\n    });\n\n    // Add the new hover provider to the subscriptions\n    if (decorations_active) {\n        context.subscriptions.push(hoverProvider);\n    }\n\n    return {\n        decorationTypes: Array.from(lineDecorations.values()).map((value) => value.decorationType),\n        hoverProvider: hoverProvider\n    };\n}\n"
            }
          ]
        }
      ],
      "selection": null,
      "timestamp": "2024-10-03T05:09:33.003Z",
      "prompt": "if the length of matchingLineNumbers is greater than 80% of the length of the addedLines, include all matchedLineNumbers",
      "parent_inline_chat_id": null
    }
  ],
  "schemaVersion": "1.0",
  "deletedChats": {
    "deletedMessageIDs": [],
    "deletedPanelChatIDs": [
      "a488df93-c80e-4a81-87ce-beec2330150e",
      "b218a37d-e155-4b81-aaa1-e6f58f48aadb"
    ]
  },
  "kv_store": {}
}