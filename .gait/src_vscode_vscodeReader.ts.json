{
    "fileName": "src/vscode/vscodeReader.ts",
    "inlineChats": {
        "593f0206-8510-49fa-87ac-ecdd85523b20": {
            "inline_chat_id": "593f0206-8510-49fa-87ac-ecdd85523b20",
            "fileName": "src/vscode/vscodeReader.ts",
            "content": "import * as vscode from 'vscode';\nimport * as Diff from 'diff';\nimport * as Inline from '../inline';\nimport { readVSCodeState } from '../tools/dbReader';\nimport { Context, MessageEntry, PanelChat, StashedState, StateReader } from '../types';\nimport { v4 as uuidv4 } from 'uuid';\nimport path from 'path';\nconst SCHEMA_VERSION = '1.0';\n\n\n/**\n * Interface representing an interactive session.\n */\ninterface InteractiveSession {\n    history: {\n        editor: {\n            text: string;\n            state: {\n                chatContextAttachments: any[];\n                chatDynamicVariableModel: any[];\n            }\n        }[];\n        copilot: any[];\n    }\n}\n\n\n/**\n * Validates if the object is a valid InteractiveSession.\n */\nfunction isValidInteractiveSession(obj: any): obj is InteractiveSession {\n    return (\n        obj &&\n        typeof obj === 'object' &&\n        obj.history &&\n        Array.isArray(obj.history.editor) &&\n        obj.history.editor.every((entry: any) =>\n            typeof entry.text === 'string' &&\n            entry.state &&\n            Array.isArray(entry.state.chatContextAttachments) &&\n            Array.isArray(entry.state.chatDynamicVariableModel)\n        )\n    );\n}\n\n/**\n * Retrieves a single new editor text from the sessions.\n */\nfunction getSingleNewEditorText(oldSessions: InteractiveSession, newSessions: InteractiveSession): string {\n    const oldEditorTexts = new Set(oldSessions.history.editor.map(entry => entry.text));\n    const newEditorTexts = newSessions.history.editor\n        .filter(entry => entry.text && !oldEditorTexts.has(entry.text))\n        .map(entry => entry.text);\n\n    if (newEditorTexts.length !== 1) {\n        throw new Error(newEditorTexts.length === 0 ? \"No new editor text found.\" : \"Multiple new editor texts found.\");\n    }\n\n    return newEditorTexts[0];\n}\n\nfunction getDBPath(context: vscode.ExtensionContext): string {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder || !context.storageUri) {\n        throw new Error('No workspace folder or storage URI found');\n    }\n    const dbPath = path.join(path.dirname(context.storageUri.fsPath), 'state.vscdb');\n    return dbPath;\n}\n\n\nexport class VSCodeReader implements StateReader {\n    private context: vscode.ExtensionContext;\n    private interactiveSessions: InteractiveSession | null = null;\n    private inlineStartInfo: Inline.InlineStartInfo | null = null;\n\n    constructor(context: vscode.ExtensionContext) {\n        this.context = context;\n    }\n\n\n    /**\n     * Initializes the extension by reading interactive sessions.\n     */\n    public async startInline(inlineStartInfo: Inline.InlineStartInfo) {\n        const interactiveSessions = await readVSCodeState(getDBPath(this.context), 'memento/interactive-session');\n        this.interactiveSessions= interactiveSessions;\n        this.inlineStartInfo = inlineStartInfo;\n    }\n\n    /**\n     * Processes the editor content during inline chat acceptance.\n     */\n    public async acceptInline(editor: vscode.TextEditor) {\n        const oldInteractiveSessions: any = this.interactiveSessions;\n        if (!isValidInteractiveSession(oldInteractiveSessions)) {\n            throw new Error('Old interactive sessions are invalid or not found.');\n        }\n\n        const newContent = editor.document.getText();\n        const lastInline = this.inlineStartInfo;\n        this.inlineStartInfo = null;\n        if (Inline.isInlineStartInfo(lastInline)) {\n            const diff = Diff.diffLines(lastInline.content, newContent);\n            await vscode.commands.executeCommand('inlineChat.acceptChanges');\n\n            await new Promise(resolve => setTimeout(resolve, 2000));\n            const newInteractiveSessions: any = await readVSCodeState(getDBPath(this.context), 'memento/interactive-session');\n            \n            if (!isValidInteractiveSession(newInteractiveSessions)) {\n                throw new Error('New interactive sessions are invalid or not found.');\n            }\n            const newChat = getSingleNewEditorText(oldInteractiveSessions, newInteractiveSessions);\n            const inlineChatInfoObj = Inline.InlineStartToInlineChatInfo(lastInline, diff, newChat);\n\n            Inline.writeInlineChat(inlineChatInfoObj);\n            this.interactiveSessions = null;\n        } else {\n            throw new Error('No valid content stored in last_inline_start');\n        }\n    }\n\n    /**\n     * Parses the panel chat from interactive sessions and assigns UUIDs based on existing order.\n     */\n    public async parsePanelChatAsync(): Promise<PanelChat[]> {\n        try {\n\n            const interactiveSessions = await readVSCodeState(getDBPath(this.context), 'interactive.sessions');\n\n            vscode.window.showInformationMessage(\"Interactive sessions: \" + interactiveSessions);\n\n            if (!interactiveSessions) {\n                vscode.window.showErrorMessage('Interactive sessions data is not available.');\n                return [];\n            }\n            \n            if (!Array.isArray(interactiveSessions)) {\n                vscode.window.showErrorMessage('Interactive sessions data is not an array.');\n                return [];\n            }\n    \n            const panelChats: PanelChat[] = interactiveSessions.map((panel: any, index: number) => {\n                const ai_editor: string = \"copilot\";\n                const customTitle: string = typeof panel.customTitle === 'string' ? panel.customTitle : '';\n    \n                // Determine if this PanelChat has an existing UUID\n                let id: string = typeof panel.sessionId === 'string' ? panel.sessionId : '';\n        \n                const parent_id: string | null = null;\n                const created_on: string = typeof panel.creationDate === 'string' ? panel.creationDate : new Date().toISOString();\n    \n                vscode.window.showInformationMessage(panel);\n\n                // Extract messages\n                const messages: MessageEntry[] = panel.requests.map((request: any) => {\n                    // Safely extract messageText\n                    vscode.window.showInformationMessage(request);\n                    const messageText: string = typeof request.message?.text === 'string' ? request.message.text : '';\n                    const id: string = typeof request.result.metadata?.modelMessageId === 'string' ? request.result.metadata?.modelMessageId: '';\n                    // Safely extract responseText\n                    let responseText: string = '';\n    \n                    if (Array.isArray(request.response)) {\n                        // Concatenate all response values into a single string, separated by newlines\n                        const validResponses = request.response\n                            .map((response: any) => response.value)\n                            .filter((value: any) => typeof value === 'string' && value.trim() !== '');\n    \n                        responseText = validResponses.join('\\n');\n                    } else if (typeof request.response?.value === 'string') {\n                        responseText = request.response.value;\n                    }\n    \n                    // Extract model and timestamp if available\n                    const model: string = typeof request.model === 'string' ? request.model : 'Unknown';\n                    const timestamp: string = typeof request.timestamp === 'string' ? request.timestamp : new Date().toISOString();\n    \n                    // Extract context if available\n                    let contextData: Context[]  = [];\n                    if (Array.isArray(request.context)) {\n                        contextData = request.context\n                            .map((ctx: any) => {\n                                if (typeof ctx.type === 'string' && typeof ctx.value === 'string') {\n                                    switch (ctx.type) {\n                                        case 'RelativePath':\n                                        case 'SymbolFromReferences':\n                                        case 'SymbolInFile':\n                                            return { context_type: ctx.type, key: ctx.key, value: ctx.value } as Context;\n                                        default:\n                                            return undefined;\n                                    }\n                                }\n                                return undefined;\n                            })\n                            .filter((ctx: Context | undefined) => ctx !== undefined) as Context[];\n                    }\n    \n                    return {\n                        id, // Assign new UUID to MessageEntry\n                        messageText,\n                        responseText,\n                        model,\n                        timestamp,\n                        context: contextData,\n                    };\n                }).filter((entry: MessageEntry) =>\n                    entry.messageText.trim() !== '' && entry.responseText.trim() !== ''\n                );\n    \n                return {\n                    ai_editor,\n                    customTitle,\n                    id,\n                    parent_id,\n                    created_on,\n                    messages,\n                } as PanelChat;\n            });\n    \n            return panelChats;\n        } catch (error) {\n            vscode.window.showErrorMessage(`Failed to parse panel chat: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            return [];\n        }\n    }\n}\n",
            "lineCount": 228,
            "startTimestamp": "2024-09-22T21:26:37.200Z",
            "startSelection": {
                "line": 130,
                "character": 12
            },
            "endSelection": {
                "line": 130,
                "character": 97
            },
            "selectionContent": "vscode.window.showInformationMessage(\"Interactive sessions: \" + interactiveSessions);",
            "endTimestamp": "2024-09-22T21:26:59.572Z",
            "prompt": "Change this to display in a new text doc instead",
            "diffs": [
                {
                    "count": 130,
                    "added": false,
                    "removed": false,
                    "value": "import * as vscode from 'vscode';\nimport * as Diff from 'diff';\nimport * as Inline from '../inline';\nimport { readVSCodeState } from '../tools/dbReader';\nimport { Context, MessageEntry, PanelChat, StashedState, StateReader } from '../types';\nimport { v4 as uuidv4 } from 'uuid';\nimport path from 'path';\nconst SCHEMA_VERSION = '1.0';\n\n\n/**\n * Interface representing an interactive session.\n */\ninterface InteractiveSession {\n    history: {\n        editor: {\n            text: string;\n            state: {\n                chatContextAttachments: any[];\n                chatDynamicVariableModel: any[];\n            }\n        }[];\n        copilot: any[];\n    }\n}\n\n\n/**\n * Validates if the object is a valid InteractiveSession.\n */\nfunction isValidInteractiveSession(obj: any): obj is InteractiveSession {\n    return (\n        obj &&\n        typeof obj === 'object' &&\n        obj.history &&\n        Array.isArray(obj.history.editor) &&\n        obj.history.editor.every((entry: any) =>\n            typeof entry.text === 'string' &&\n            entry.state &&\n            Array.isArray(entry.state.chatContextAttachments) &&\n            Array.isArray(entry.state.chatDynamicVariableModel)\n        )\n    );\n}\n\n/**\n * Retrieves a single new editor text from the sessions.\n */\nfunction getSingleNewEditorText(oldSessions: InteractiveSession, newSessions: InteractiveSession): string {\n    const oldEditorTexts = new Set(oldSessions.history.editor.map(entry => entry.text));\n    const newEditorTexts = newSessions.history.editor\n        .filter(entry => entry.text && !oldEditorTexts.has(entry.text))\n        .map(entry => entry.text);\n\n    if (newEditorTexts.length !== 1) {\n        throw new Error(newEditorTexts.length === 0 ? \"No new editor text found.\" : \"Multiple new editor texts found.\");\n    }\n\n    return newEditorTexts[0];\n}\n\nfunction getDBPath(context: vscode.ExtensionContext): string {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder || !context.storageUri) {\n        throw new Error('No workspace folder or storage URI found');\n    }\n    const dbPath = path.join(path.dirname(context.storageUri.fsPath), 'state.vscdb');\n    return dbPath;\n}\n\n\nexport class VSCodeReader implements StateReader {\n    private context: vscode.ExtensionContext;\n    private interactiveSessions: InteractiveSession | null = null;\n    private inlineStartInfo: Inline.InlineStartInfo | null = null;\n\n    constructor(context: vscode.ExtensionContext) {\n        this.context = context;\n    }\n\n\n    /**\n     * Initializes the extension by reading interactive sessions.\n     */\n    public async startInline(inlineStartInfo: Inline.InlineStartInfo) {\n        const interactiveSessions = await readVSCodeState(getDBPath(this.context), 'memento/interactive-session');\n        this.interactiveSessions= interactiveSessions;\n        this.inlineStartInfo = inlineStartInfo;\n    }\n\n    /**\n     * Processes the editor content during inline chat acceptance.\n     */\n    public async acceptInline(editor: vscode.TextEditor) {\n        const oldInteractiveSessions: any = this.interactiveSessions;\n        if (!isValidInteractiveSession(oldInteractiveSessions)) {\n            throw new Error('Old interactive sessions are invalid or not found.');\n        }\n\n        const newContent = editor.document.getText();\n        const lastInline = this.inlineStartInfo;\n        this.inlineStartInfo = null;\n        if (Inline.isInlineStartInfo(lastInline)) {\n            const diff = Diff.diffLines(lastInline.content, newContent);\n            await vscode.commands.executeCommand('inlineChat.acceptChanges');\n\n            await new Promise(resolve => setTimeout(resolve, 2000));\n            const newInteractiveSessions: any = await readVSCodeState(getDBPath(this.context), 'memento/interactive-session');\n            \n            if (!isValidInteractiveSession(newInteractiveSessions)) {\n                throw new Error('New interactive sessions are invalid or not found.');\n            }\n            const newChat = getSingleNewEditorText(oldInteractiveSessions, newInteractiveSessions);\n            const inlineChatInfoObj = Inline.InlineStartToInlineChatInfo(lastInline, diff, newChat);\n\n            Inline.writeInlineChat(inlineChatInfoObj);\n            this.interactiveSessions = null;\n        } else {\n            throw new Error('No valid content stored in last_inline_start');\n        }\n    }\n\n    /**\n     * Parses the panel chat from interactive sessions and assigns UUIDs based on existing order.\n     */\n    public async parsePanelChatAsync(): Promise<PanelChat[]> {\n        try {\n\n            const interactiveSessions = await readVSCodeState(getDBPath(this.context), 'interactive.sessions');\n\n"
                },
                {
                    "count": 1,
                    "added": false,
                    "removed": true,
                    "value": "            vscode.window.showInformationMessage(\"Interactive sessions: \" + interactiveSessions);\n"
                },
                {
                    "count": 2,
                    "added": true,
                    "removed": false,
                    "value": "            const newDocument = await vscode.workspace.openTextDocument({ content: \"Interactive sessions: \" + JSON.stringify(interactiveSessions, null, 2) });\n            await vscode.window.showTextDocument(newDocument);\n"
                },
                {
                    "count": 96,
                    "added": false,
                    "removed": false,
                    "value": "\n            if (!interactiveSessions) {\n                vscode.window.showErrorMessage('Interactive sessions data is not available.');\n                return [];\n            }\n            \n            if (!Array.isArray(interactiveSessions)) {\n                vscode.window.showErrorMessage('Interactive sessions data is not an array.');\n                return [];\n            }\n    \n            const panelChats: PanelChat[] = interactiveSessions.map((panel: any, index: number) => {\n                const ai_editor: string = \"copilot\";\n                const customTitle: string = typeof panel.customTitle === 'string' ? panel.customTitle : '';\n    \n                // Determine if this PanelChat has an existing UUID\n                let id: string = typeof panel.sessionId === 'string' ? panel.sessionId : '';\n        \n                const parent_id: string | null = null;\n                const created_on: string = typeof panel.creationDate === 'string' ? panel.creationDate : new Date().toISOString();\n    \n                vscode.window.showInformationMessage(panel);\n\n                // Extract messages\n                const messages: MessageEntry[] = panel.requests.map((request: any) => {\n                    // Safely extract messageText\n                    vscode.window.showInformationMessage(request);\n                    const messageText: string = typeof request.message?.text === 'string' ? request.message.text : '';\n                    const id: string = typeof request.result.metadata?.modelMessageId === 'string' ? request.result.metadata?.modelMessageId: '';\n                    // Safely extract responseText\n                    let responseText: string = '';\n    \n                    if (Array.isArray(request.response)) {\n                        // Concatenate all response values into a single string, separated by newlines\n                        const validResponses = request.response\n                            .map((response: any) => response.value)\n                            .filter((value: any) => typeof value === 'string' && value.trim() !== '');\n    \n                        responseText = validResponses.join('\\n');\n                    } else if (typeof request.response?.value === 'string') {\n                        responseText = request.response.value;\n                    }\n    \n                    // Extract model and timestamp if available\n                    const model: string = typeof request.model === 'string' ? request.model : 'Unknown';\n                    const timestamp: string = typeof request.timestamp === 'string' ? request.timestamp : new Date().toISOString();\n    \n                    // Extract context if available\n                    let contextData: Context[]  = [];\n                    if (Array.isArray(request.context)) {\n                        contextData = request.context\n                            .map((ctx: any) => {\n                                if (typeof ctx.type === 'string' && typeof ctx.value === 'string') {\n                                    switch (ctx.type) {\n                                        case 'RelativePath':\n                                        case 'SymbolFromReferences':\n                                        case 'SymbolInFile':\n                                            return { context_type: ctx.type, key: ctx.key, value: ctx.value } as Context;\n                                        default:\n                                            return undefined;\n                                    }\n                                }\n                                return undefined;\n                            })\n                            .filter((ctx: Context | undefined) => ctx !== undefined) as Context[];\n                    }\n    \n                    return {\n                        id, // Assign new UUID to MessageEntry\n                        messageText,\n                        responseText,\n                        model,\n                        timestamp,\n                        context: contextData,\n                    };\n                }).filter((entry: MessageEntry) =>\n                    entry.messageText.trim() !== '' && entry.responseText.trim() !== ''\n                );\n    \n                return {\n                    ai_editor,\n                    customTitle,\n                    id,\n                    parent_id,\n                    created_on,\n                    messages,\n                } as PanelChat;\n            });\n    \n            return panelChats;\n        } catch (error) {\n            vscode.window.showErrorMessage(`Failed to parse panel chat: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            return [];\n        }\n    }\n}\n"
                }
            ],
            "parent_inline_chat_id": null
        }
    }
}